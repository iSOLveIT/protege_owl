


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="_static/onto-favicon.svg">
    
    
<title>Protégé OWL Docs</title>


      
        <title>Protégé OWL</title>
      
    
    
      <link rel="stylesheet" href="_static/stylesheets/main.8674dc46.min.css">
      
        
        <link rel="stylesheet" href="_static/stylesheets/palette.92c9fe4a.min.css">
        
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
        <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
        <link rel="stylesheet" type="text/css" href="_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
        <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <script>__md_scope=new URL(".",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="blue" data-md-color-accent="teal">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="#" title="Protégé OWL" class="md-header__button md-logo" aria-label="Protégé OWL" data-md-component="logo">
      <img src="_static/onto-logo.svg" alt="logo">
    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Protégé OWL
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              1. Introduction
            
          </span>
        </div>
      </div>
    </div>
    
      <form class="md-header__option" data-md-component="palette">
        
          
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="blue" data-md-color-accent="teal"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
          
            <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3 3.19.09m3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95 2.06.05m-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31Z"/></svg>
            </label>
          
        
          
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="blue" data-md-color-accent="teal"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_2">
          
            <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5c-.84 0-1.65.15-2.39.42L12 2M3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29L3.34 7m.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14L3.36 17M20.65 7l-1.77 3.79a7.023 7.023 0 0 0-2.38-4.15l4.15.36m-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29L20.64 17M12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44L12 22Z"/></svg>
            </label>
          
        
      </form>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" aria-label="Share" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/iSOLveIT/protege_owl" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM277.3 415.7c-8.4 1.5-11.5-3.7-11.5-8 0-5.4.2-33 .2-55.3 0-15.6-5.2-25.5-11.3-30.7 37-4.1 76-9.2 76-73.1 0-18.2-6.5-27.3-17.1-39 1.7-4.3 7.4-22-1.7-45-13.9-4.3-45.7 17.9-45.7 17.9-13.2-3.7-27.5-5.6-41.6-5.6-14.1 0-28.4 1.9-41.6 5.6 0 0-31.8-22.2-45.7-17.9-9.1 22.9-3.5 40.6-1.7 45-10.6 11.7-15.6 20.8-15.6 39 0 63.6 37.3 69 74.3 73.1-4.8 4.3-9.1 11.7-10.6 22.3-9.5 4.3-33.8 11.7-48.3-13.9-9.1-15.8-25.5-17.1-25.5-17.1-16.2-.2-1.1 10.2-1.1 10.2 10.8 5 18.4 24.2 18.4 24.2 9.7 29.7 56.1 19.7 56.1 19.7 0 13.9.2 36.5.2 40.6 0 4.3-3 9.5-11.5 8-66-22.1-112.2-84.9-112.2-158.3 0-91.8 70.2-161.5 162-161.5S388 165.6 388 257.4c.1 73.4-44.7 136.3-110.7 158.3zm-98.1-61.1c-1.9.4-3.7-.4-3.9-1.7-.2-1.5 1.1-2.8 3-3.2 1.9-.2 3.7.6 3.9 1.9.3 1.3-1 2.6-3 3zm-9.5-.9c0 1.3-1.5 2.4-3.5 2.4-2.2.2-3.7-.9-3.7-2.4 0-1.3 1.5-2.4 3.5-2.4 1.9-.2 3.7.9 3.7 2.4zm-13.7-1.1c-.4 1.3-2.4 1.9-4.1 1.3-1.9-.4-3.2-1.9-2.8-3.2.4-1.3 2.4-1.9 4.1-1.5 2 .6 3.3 2.1 2.8 3.4zm-12.3-5.4c-.9 1.1-2.8.9-4.3-.6-1.5-1.3-1.9-3.2-.9-4.1.9-1.1 2.8-.9 4.3.6 1.3 1.3 1.8 3.3.9 4.1zm-9.1-9.1c-.9.6-2.6 0-3.7-1.5s-1.1-3.2 0-3.9c1.1-.9 2.8-.2 3.7 1.3 1.1 1.5 1.1 3.3 0 4.1zm-6.5-9.7c-.9.9-2.4.4-3.5-.6-1.1-1.3-1.3-2.8-.4-3.5.9-.9 2.4-.4 3.5.6 1.1 1.3 1.3 2.8.4 3.5zm-6.7-7.4c-.4.9-1.7 1.1-2.8.4-1.3-.6-1.9-1.7-1.5-2.6.4-.6 1.5-.9 2.8-.4 1.3.7 1.9 1.8 1.5 2.6z"/></svg>
  </div>
  <div class="md-source__repository">
    Protégé
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary">
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#" class="md-nav__link">
    <span title="index (document)" class="md-ellipsis">1.<wbr>   Introduction</span>
  </a>
  
    <nav class="md-nav" aria-label="1.   Introduction">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#licensing" class="md-nav__link">
    <span class="md-ellipsis">1.<wbr>1.<wbr>   Licensing</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conventions" class="md-nav__link">
    <span class="md-ellipsis">1.<wbr>2.<wbr>   Conventions</span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#requirements-and-the-protege-user-interface" class="md-nav__link">
    <span class="md-ellipsis">2.<wbr>   Requirements and the Protégé User Interface</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#what-are-owl-ontologies" class="md-nav__link">
    <span class="md-ellipsis">3.<wbr>   What are OWL Ontologies?</span>
  </a>
  
    <nav class="md-nav" aria-label="3.   What are OWL Ontologies?">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#components-of-owl-ontologies" class="md-nav__link">
    <span class="md-ellipsis">3.<wbr>1.<wbr>   Components of OWL Ontologies</span>
  </a>
  
    <nav class="md-nav" aria-label="3.1.   Components of OWL Ontologies">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#individuals" class="md-nav__link">
    <span class="md-ellipsis">3.<wbr>1.<wbr>1.<wbr>   Individuals</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#properties" class="md-nav__link">
    <span class="md-ellipsis">3.<wbr>1.<wbr>2.<wbr>   Properties</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#classes" class="md-nav__link">
    <span class="md-ellipsis">3.<wbr>1.<wbr>3.<wbr>   Classes</span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#building-an-owl-ontology" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>   Building an OWL Ontology</span>
  </a>
  
    <nav class="md-nav" aria-label="4.   Building an OWL Ontology">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#named-classes" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>1.<wbr>   Named Classes</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#using-a-reasoner" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>2.<wbr>   Using a Reasoner</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#disjoint-classes" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>3.<wbr>   Disjoint Classes</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#using-create-class-hierarchy" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>4.<wbr>   Using Create Class Hierarchy</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-a-pizzatopping-hierarchy" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>5.<wbr>   Create a Pizza<wbr>Topping Hierarchy</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#owl-properties" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>6.<wbr>   OWL Properties</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inverse-properties" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>7.<wbr>   Inverse Properties</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#owl-object-property-characteristics" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>8.<wbr>   OWL Object Property Characteristics</span>
  </a>
  
    <nav class="md-nav" aria-label="4.8.   OWL Object Property Characteristics">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#functional-properties" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>8.<wbr>1.<wbr>   Functional Properties</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inverse-functional-properties" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>8.<wbr>2.<wbr>   Inverse Functional Properties</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transitive-properties" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>8.<wbr>3.<wbr>   Transitive Properties</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#symmetric-and-asymmetric-properties" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>8.<wbr>4.<wbr>   Symmetric and Asymmetric Properties</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reflexive-and-irreflexive-properties" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>8.<wbr>5.<wbr>   Reflexive and Irreflexive Properties</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reasoners-automatically-enforce-property-characteristics" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>8.<wbr>6.<wbr>   Reasoners Automatically Enforce Property Characteristics</span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#owl-property-domains-and-ranges" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>9.<wbr>   OWL Property Domains and Ranges</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#describing-and-defining-classes" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>10.<wbr>   Describing and Defining Classes</span>
  </a>
  
    <nav class="md-nav" aria-label="4.10.   Describing and Defining Classes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#property-restrictions" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>10.<wbr>1.<wbr>   Property restrictions</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#existential-restrictions" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>10.<wbr>2.<wbr>   Existential Restrictions</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#creating-subclasses-of-pizza" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>10.<wbr>3.<wbr>   Creating Subclasses of Pizza</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#detecting-a-class-that-can-t-have-members" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>10.<wbr>4.<wbr>   Detecting a Class that can’t Have Members</span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#primitive-and-defined-classes-necessary-and-sufficient-axioms" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>11.<wbr>   Primitive and Defined Classes <wbr>(Necessary and Sufficient Axioms)</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#universal-restrictions" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>12.<wbr>   Universal Restrictions</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#automated-classification-and-open-world-reasoning" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>13.<wbr>   Automated Classification and Open World Reasoning</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#defining-an-enumerated-class" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>14.<wbr>   Defining an Enumerated Class</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adding-spiciness-as-a-property" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>15.<wbr>   Adding Spiciness as a Property</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cardinality-restrictions" class="md-nav__link">
    <span class="md-ellipsis">4.<wbr>16.<wbr>   Cardinality Restrictions</span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#datatype-properties" class="md-nav__link">
    <span class="md-ellipsis">5.<wbr>   Datatype Properties</span>
  </a>
  
    <nav class="md-nav" aria-label="5.   Datatype Properties">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#defining-a-data-property" class="md-nav__link">
    <span class="md-ellipsis">5.<wbr>1.<wbr>   Defining a Data Property</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#customizing-the-protege-user-interface" class="md-nav__link">
    <span class="md-ellipsis">5.<wbr>2.<wbr>   Customizing the Protégé User Interface</span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adding-order-to-an-enumerated-class" class="md-nav__link">
    <span class="md-ellipsis">6.<wbr>   Adding Order to an Enumerated Class</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#names-iri-s-labels-and-namespaces" class="md-nav__link">
    <span class="md-ellipsis">7.<wbr>   Names:<wbr> IRI’s, Labels, and Namespaces</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#a-larger-ontology-with-some-individuals" class="md-nav__link">
    <span class="md-ellipsis">8.<wbr>   A Larger Ontology with some Individuals</span>
  </a>
  
    <nav class="md-nav" aria-label="8.   A Larger Ontology with some Individuals">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#get-familiar-with-the-larger-ontology" class="md-nav__link">
    <span class="md-ellipsis">8.<wbr>1.<wbr>   Get Familiar with the Larger Ontology</span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#queries-description-logic-and-sparql" class="md-nav__link">
    <span class="md-ellipsis">9.<wbr>   Queries:<wbr> Description Logic and SPARQL</span>
  </a>
  
    <nav class="md-nav" aria-label="9.   Queries: Description Logic and SPARQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#description-logic-queries" class="md-nav__link">
    <span class="md-ellipsis">9.<wbr>1.<wbr>   Description Logic Queries</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sparql-queries" class="md-nav__link">
    <span class="md-ellipsis">9.<wbr>2.<wbr>   SPARQL Queries</span>
  </a>
  
    <nav class="md-nav" aria-label="9.2.   SPARQL Queries">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#some-sparql-pizza-queries" class="md-nav__link">
    <span class="md-ellipsis">9.<wbr>2.<wbr>1.<wbr>   Some SPARQL Pizza Queries</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sparql-and-iri-names" class="md-nav__link">
    <span class="md-ellipsis">9.<wbr>2.<wbr>2.<wbr>   SPARQL and IRI Names</span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#swrl-and-sqwrl" class="md-nav__link">
    <span class="md-ellipsis">10.<wbr>   SWRL and SQWRL</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-11" class="md-nav__link">
    <span class="md-ellipsis">11.<wbr>   Chapter 11</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-12" class="md-nav__link">
    <span class="md-ellipsis">12.<wbr>   Chapter 12</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-13" class="md-nav__link">
    <span class="md-ellipsis">13.<wbr>   Chapter 13</span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset" role="main">
                
  <a href="https://github.com/iSOLveIT/protege_owl/blob/main/docs/source/index.rst" title="Edit this page" class="md-content__button md-icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25Z"/></svg>
  </a>



  <p class="centered">
<strong>A Practical Guide to Building OWL Ontologies</strong></p><p class="centered">
<strong>Using Protégé 5.5 and Plugins</strong></p><p class="centered">
<strong>Edition 3.2</strong></p><p><strong>Author:</strong> Michael DeBellis</p>
<p><strong>Organization:</strong> Ontomatica</p>
<p><strong>Revision:</strong> 8th October, 2021</p>
<hr class="docutils" />
<p>This is a revised version of the Protégé 4 Tutorial version 1.3 by
<strong>Matthew Horridge</strong>. Previous versions of the tutorial were developed by
Holger Knublauch , Alan Rector , Robert Stevens, Chris Wroe, Simon Jupp,
Georgina Moulton, Nick Drummond, and Sebastian Brandt.</p>
<p>This work was conducted using the Protégé resource, which is supported
by grant GM10331601 from the National Institute of General Medical
Sciences of the United States National Institutes of Health.</p>
<p>Chapters 3-5 are based on the original tutorial. I have updated the
tutorial to be consistent with Protégé 5. I have also made some changes
to address some of the most common issues I’ve seen new users grapple
with, to remove some of the dated information about older frame-based
versions of Protégé, and various miscellaneous changes.</p>
<p>Chapters 6-11 are new. I have added new sections for technologies such as SWRL, SPARQL
and SHACL as well as some details on concepts such as IRIs and
namespaces.</p>
<p>Thanks to Matthew Horridge and everyone who worked on the previous
tutorials. Special thanks to Lorenz Buehmann who helped me work out a
thorny problem as I developed the revised example and to André Wolski
for help with the SHACL plugin. Special thanks to Dick Ooms, Colin
Pilkington, and Livia Pinera for their excellent detailed feedback on
previous versions of the tutorial. Special thanks to Jans Aasman, Yan
Xu, and everyone at Franz Inc. for their help utilizing AllegroGraph and
Gruff for this tutorial and for a new tutorial available at: <a class="reference external" href="https://www.michaeldebellis.com/post/the-people_example-ontology">https://www.michaeldebellis.com/post/the-people_example-ontology</a></p>
<p>Also, thanks to everyone on the Protégé user support email list.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This document may get updates frequently. It is a good idea to check my blog at:
<a class="reference external" href="https://www.michaeldebellis.com/post/new-protege-pizza-tutorial">https://www.michaeldebellis.com/post/new-protege-pizza-tutorial</a> to make sure you have the latest version.</p>
</div>
<p>If you have questions or comments, feel free to contact me at <a class="reference external" href="mailto:mdebellissf&#37;&#52;&#48;gmail&#46;com">mdebellissf<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
<h1 id="introduction"><span id="chap1"></span><span class="sectnum">1. </span>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">¶</a></h1>
<p>This introduces Protégé 5 for creating OWL ontologies as well as various
plugins. If you have questions specific to this tutorial, please feel
free to email me directly: <a class="reference external" href="mailto:mdebellissf&#37;&#52;&#48;gmail&#46;com">mailto:mdebellissf<span>&#64;</span>gmail<span>&#46;</span>com</a>
However, if you have general questions about
Protégé, OWL, or plugins you end an email to the User Support for
Protégé and Web Protégé email list. This list has many people (including
me) who monitor it and can contribute their knowledge to help you
understand how to get the most out of this technology. To subscribe to
the list, go to: <a class="reference external" href="https://protege.stanford.edu/support.php">https://protege.stanford.edu/support.php</a>
and click on the first orange <cite>Subscribe</cite> button. That
will enable he email to send questions to.</p>
<p>This chapter covers licensing and describes conventions used in the
tutorial. <a class="reference internal" href="#chap2"><span class="std std-ref">Chapter 2</span></a> covers the requirements for the tutorial and
describes the Protégé user interface. <a class="reference internal" href="#chap3"><span class="std std-ref">Chapter 3</span></a> gives a brief overview
of the OWL ontology language. <a class="reference internal" href="#chap4"><span class="std std-ref">Chapter 4</span></a> focuses on building an OWL
ontology with classes and object properties. <a class="reference internal" href="#chap4"><span class="std std-ref">Chapter 4</span></a> also describes
using a Description Logic Reasoner to check the consistency of the
ontology and automatically compute the ontology class hierarchy.</p>
<p><a class="reference internal" href="#chap5"><span class="std std-ref">Chapter 5</span></a> describes data properties. <a class="reference internal" href="#chap6"><span class="std std-ref">Chapter 6</span></a> describes design patterns
and shows one design pattern: adding an order to an enumerated class.
<a class="reference internal" href="#chap7"><span class="std std-ref">Chapter 7</span></a> describes the various concepts related to the name of an OWL
entity.</p>
<p><a class="reference internal" href="#chap8"><span class="std std-ref">Chapter 8</span></a> introduces an extended version of the Pizza tutorial developed
in chapters 1-7. This ontology has a small number of instances and
property values already created which can be used to illustrate the
tools in the later chapters for writing rules, doing queries, and
defining constraints.</p>
<p><a class="reference internal" href="#chap9"><span class="std std-ref">Chapter 9</span></a> describes two tools for doing queries: Description Logic
queries and SPARQL queries. <a class="reference internal" href="#chap10"><span class="std std-ref">Chapter 10</span></a> introduces the Semantic Web Rule
Language (SWRL) and walks you through creating SWRL and SQWRL rules.
<a class="reference internal" href="#chap11"><span class="std std-ref">Chapter 11</span></a> introduces the Shapes Constraint Language (SHACL) and
discusses the difference between defining logical axioms in Description
Logic and data integrity constraints in SHACL. <a class="reference internal" href="#chap12"><span class="std std-ref">Chapter 12</span></a> has some
concluding thoughts and opinions and <a class="reference internal" href="#chap13"><span class="std std-ref">Chapter 13</span></a> provides a bibliography.</p>
<h2 id="licensing"><span class="sectnum">1.1. </span>Licensing<a class="headerlink" href="#licensing" title="Permalink to this heading">¶</a></h2>
<p>This document is freely available under the Creative Commons
Attribution-ShareAlike 4.0 International Public License. I typically
distribute it as a PDF but if you want to make your own version send
me an email and I will send you the Word version. For details on
licensing see: <a class="reference external" href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">https://creativecommons.org/licenses/by-sa/4.0/legalcode</a></p>
<h2 id="conventions"><span class="sectnum">1.2. </span>Conventions<a class="headerlink" href="#conventions" title="Permalink to this heading">¶</a></h2>
<p>Class, property, rule, and individual names are written in Consolas font
like this. The term used for any such construct in Protégé and in this
document is an <em>Entity</em>. Individuals and classes can also be referred to
as objects.</p>
<p>Names for user interface tabs, views, menu selections, buttons, and text
entry are highlighted <cite>like this:</cite>.</p>
<p>Any time you see highlighted text such as <cite>File&gt;Preferences</cite> or <cite>OK</cite> or
<cite>PizzaTopping</cite> it refers to something that you should or optionally could
view or enter into the user interface. If you ever aren’t sure what to
do to accomplish some task look for the highlighted text. Often, as with
PizzaTopping the text you enter into a field in the Protégé UI will be
the name of a class, property, etc. In those cases, where the name is meant
to be entered into a field it will only be highlighted
rather than highlighted and printed in Consolas font.</p>
<p>Menu options are shown with the name of the top-level menu, followed by
a &gt; followed by the next level down to the desired selection. For
example, to indicate how to open the <cite>Individuals by class</cite> tab under the
<cite>Tabs</cite> section in the <cite>Window</cite> menu the following text would be used:
<cite>Window&gt;Tabs&gt;Individuals by class</cite>.</p>
<div class="line-block">
<div class="line">When a word or phrase is emphasized, it is <em>shown in italics like
this</em>.</div>
</div>
<p>Exercises are presented like this:</p>
<p><strong>Exercise X: Accomplish this</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Do this.</p></li>
<li><p>Then do this.</p></li>
<li><p>Then do this.</p></li>
</ol>
<hr class="docutils" />
<div class="pitfall admonition">
<p class="admonition-title">Warning</p>
<p>Potential pitfalls and warnings are presented like this.</p>
</div>
<div class="suggest admonition">
<p class="admonition-title">Tip</p>
<p>Tips and suggestions related to using Protégé are presented like this.</p>
</div>
<div class="explain admonition">
<p class="admonition-title">Explanation</p>
<p>Explanations as to what things mean are presented like this.</p>
</div>
<div class="notes admonition">
<p class="admonition-title">Note</p>
<p>General notes are presented like this.</p>
</div>
<div class="vocab admonition">
<p class="admonition-title">Vocab</p>
<p>Vocabulary explanations and alternative names are presented like this.</p>
</div>
<h1 id="requirements-and-the-protege-user-interface"><span id="chap2"></span><span class="sectnum">2. </span>Requirements and the Protégé User Interface<a class="headerlink" href="#requirements-and-the-protege-user-interface" title="Permalink to this heading">¶</a></h1>
<p>In order to follow this tutorial, you must have Protégé 5, which is
available from the Protégé website,1 and some of the Protégé Plugins
which will be described in more detail below. For now, just make sure
you have the latest version of Protégé. At the time this is being
written the latest version is 5.5 although the tutorial should work for
later versions as well.</p>
<p>The Protégé user interface is divided up into a set of major tabs.
These tabs can be seen in the
<cite>Window&gt;Tabs</cite> option. This option shows all the UI tabs that are
currently loaded into the Protégé environment. Any tabs that are
currently opened have a check mark next to them. To see a tab that is
not visible just select it from the menu and it will be added to the
top with the other major tabs and its menu item will now be checked.
You can add additional major tabs to your environment by loading
plugins. For example, when we load the SHACL4Protégé plugin the
SHACLEditor will be added to the menu.</p>
<p>Each major tab consists of various panes or as Protégé calls them views.
Each view can be resized or closed using the icons in the top right
corner of every view. The views can also be nested as sub-tabs within
each major tab. When there could potentially be confusion between a tab
that is a screen all its own (is under the <cite>Window&gt;Tabs</cite> option) and a
view that is a sub-tab we will call the screen tab a major tab.</p>
<p>There are many views that are not in the default version of Protégé
that can be added via the <cite>Window&gt;Views</cite> option. The additional views
are divided into various categories such as
<cite>Window&gt;Views&gt;Individual views</cite>. <a class="reference external" href="#customizing-the-protégé-user-interface">Section 5.2</a> will show an example of
adding a new view to a major tab.</p>
<h1 id="what-are-owl-ontologies"><span id="chap3"></span><span class="sectnum">3. </span>What are OWL Ontologies?<a class="headerlink" href="#what-are-owl-ontologies" title="Permalink to this heading">¶</a></h1>
<p>Ontologies are used to capture knowledge about some domain of interest.
An ontology describes the concepts in the domain and also the
relationships that hold between those concepts. Different ontology
languages provide different facilities. The most recent development in
standard ontology languages is OWL from the World Wide Web Consortium
(W3C). A good primer on the basic concepts of OWL can be found at: <a class="reference external" href="https://www.w3.org/TR/owl2-primer/">https://www.w3.org/TR/owl2-primer/</a></p>
<p>OWL makes unambiguous manner based on set theory and logic. Complex
concepts can be built up out of simpler concepts. The logical model
allows the use of a reasoner which can check whether all of the
statements and definitions in the ontology are mutually consistent and
can also recognize which concepts fit under which definitions. The
reasoner can therefore help to maintain the hierarchy correctly. This is
particularly useful when dealing with cases where classes can have more
than one parent. The reasoner can also infer additional information. For
example, if two properties are inverses only one value needs to be
asserted by the user and the inverse value will be automatically
inferred by the reasoner.</p>
<h2 id="components-of-owl-ontologies"><span class="sectnum">3.1. </span>Components of OWL Ontologies<a class="headerlink" href="#components-of-owl-ontologies" title="Permalink to this heading">¶</a></h2>
<p>An OWL ontology consists of Classes, Properties, and Individuals. OWL
ontologies are an implementation of Description Logic (DL) which is a decidable subset
of First Order Logic. A class in OWL is a set, a property is a binary
relation, and an individual is an element of a set. Other concepts
from set theory are also implemented in OWL such as Disjoint sets, the
Empty set (<code class="docutils literal notranslate"><span class="pre">owl:Nothing</span></code>), inverse relations, transitive relations, and many more.</p>
<p>An understanding of the basic concepts of set theory will help the user get the most out of OWL
but is not required. One of the benefits of Protégé is that it presents
an intuitive GUI that enables domain experts to define models without a
background in set theory. However, developers are encouraged to refresh
their knowledge on logic and set theory. A good source is the first 3
chapters in Elements of the Theory of Computation by Lewis and
Papadamitrious. Another good source is the PDF document <em>Overview of Set
Theory</em> available at: <a class="reference external" href="https://www.michaeldebellis.com/post/owl-theoretical-basics">https://www.michaeldebellis.com/post/owl-theoretical-basics</a></p>
<h3 id="individuals"><span class="sectnum">3.1.1. </span>Individuals<a class="headerlink" href="#individuals" title="Permalink to this heading">¶</a></h3>
<p>Individuals represent objects in the domain of interest. An important
difference between OWL and most programming and knowledge representation
languages is that OWL does not use the Unique Name Assumption (UNA).
This means that two different names could actually refer to the same
individual. For example, “Queen Elizabeth”, “The Queen” and “Elizabeth
Windsor” might all refer to the same individual. In OWL, it must be
explicitly stated that individuals are the same as each other, or
different from each other. Figure 3.1 shows a representation of some
individuals in a domain of people, nations, and relations — in this
tutorial we represent individuals as diamonds.</p>
<figure class="align-center align-default" id="id6">
<img alt="_images/1.png" class="no-scaled-link" src="_images/1.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 3.1: Representation of Individuals</em></span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center align-default" id="id7">
<img alt="_images/2.png" class="no-scaled-link" src="_images/2.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 3.2: Representation of Properties</em></span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<div class="vocab admonition">
<p class="admonition-title">Vocab</p>
<p>Individuals are also known as <em>instances</em>. Individuals can be
referred to as <em>instances of classes</em>.</p>
</div>
<h3 id="properties"><span class="sectnum">3.1.2. </span>Properties<a class="headerlink" href="#properties" title="Permalink to this heading">¶</a></h3>
<p>Properties are binary relations between individuals. I.e.,
properties link two individuals together. For example, the property
<code class="docutils literal notranslate"><span class="pre">hasFriend</span></code> might link the individual <code class="docutils literal notranslate"><span class="pre">Biswanath</span></code> to the individual
<code class="docutils literal notranslate"><span class="pre">Michael</span></code>, or the property <code class="docutils literal notranslate"><span class="pre">hasChild</span></code> might link the individual <code class="docutils literal notranslate"><span class="pre">Michael</span></code>
to the individual <code class="docutils literal notranslate"><span class="pre">Oriana</span></code>. Properties can have inverses. For
example, the inverse of <code class="docutils literal notranslate"><span class="pre">hasChild</span></code> is <code class="docutils literal notranslate"><span class="pre">hasParent</span></code>. Properties can be
limited to having a single value – i.e., to being functional. They
can also be transitive or symmetric. These property characteristics
are explained in detail in <a class="reference external" href="#owl-object-property-characteristics">Section 4.8</a>. Figure 3.2 shows a
representation of some properties.</p>
<figure class="align-center align-default" id="id8">
<img alt="_images/3.png" class="no-scaled-link" src="_images/3.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 3.3: Representation of Classes containing Individuals</em></span><a class="headerlink" href="#id8" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id8" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<div class="vocab admonition">
<p class="admonition-title">Vocab</p>
<p>Properties are similar to properties in Object-Oriented
Programming (OOP). However, there are important differences
between properties in OWL and OOP. The most important difference
is that OWL properties are first class entities that exist
independent of classes. OOP developers are encouraged to read:
<a class="reference external" href="https://www.w3.org/2001/sw/BestPractices/SE/ODSD/">https://www.w3.org/2001/sw/BestPractices/SE/ODSD/</a></p>
</div>
<h3 id="classes"><span class="sectnum">3.1.3. </span>Classes<a class="headerlink" href="#classes" title="Permalink to this heading">¶</a></h3>
<p>OWL classes are sets that contain individuals. They are described
using formal (mathematical) descriptions that rigorously define the requirements for membership
of the class. For example, the class <code class="docutils literal notranslate"><span class="pre">Cat</span></code> would contain all the
individuals that are cats in our domain of interest. Classes may
be organized into a superclass-subclass hierarchy, which is also
known as a taxonomy. However, taxonomies are often trees. I.e.,
each node has only one parent node. Class hierarchies in OWL are
not restricted to be trees and multiple inheritance can be a
powerful tool to represent data in an intuitive manner.</p>
<p>Subclasses specialize (aka <em>are subsumed by</em>) their superclasses. For
example, consider the classes <code class="docutils literal notranslate"><span class="pre">Animal</span></code> and <code class="docutils literal notranslate"><span class="pre">Dog</span></code> – <code class="docutils literal notranslate"><span class="pre">Dog</span></code> might be a
subclass of <code class="docutils literal notranslate"><span class="pre">Animal</span></code> (so <code class="docutils literal notranslate"><span class="pre">Animal</span></code> is the superclass of <code class="docutils literal notranslate"><span class="pre">Dog</span></code>). This says
that <em>All dogs are animals</em>, <em>All members of the class</em> <code class="docutils literal notranslate"><span class="pre">Dog</span></code> <em>are
members of the class</em> <code class="docutils literal notranslate"><span class="pre">Animal</span></code>. OWL and Protégé provide a language
that is called Description Logic or DL for short. One
of the key features of DL is that these superclass-subclass
relationships (aka subsumption relationships) can be computed
automatically by a reasoner – more on this later. Figure 3.3 shows a
representation of some classes containing individuals – classes are
represented as ovals, like sets in Venn diagrams.</p>
<p>In OWL classes can be built up of descriptions that specify the
conditions that must be satisﬁed by an individual for it to be a member
of the class. How to formulate these descriptions will be explained as
the tutorial progresses.</p>
<h1 id="building-an-owl-ontology"><span id="chap4"></span><span class="sectnum">4. </span>Building an OWL Ontology<a class="headerlink" href="#building-an-owl-ontology" title="Permalink to this heading">¶</a></h1>
<p>This chapter describes how to create an ontology of Pizzas. We use
Pizzas because it is something almost everyone is familiar with.</p>
<p><strong>Exercise 1: Create a new OWL Ontology</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Start Protégé. When Protégé opens for the first time each day it
puts up a screen of all the available plugins. You can also bring
this up at any time by using <cite>File&gt;Check for plugins</cite>. You won’t need
any plugins at this point of the tutorial so just click the <cite>Not now
button</cite>.</p></li>
<li><p>The Protégé user-interface consists of several tabs such as <cite>Active
ontology</cite>, <cite>Entities</cite>, etc. When you start Protégé you should be in the
<cite>Active Ontology</cite> tab. This is for overview information about the
entire ontology. Protégé always opens with a new untitled ontology
you can start with. Your ontology should have an IRI something like:
<a class="reference external" href="http://www.semanticweb.org/yourname/ontologies/2020/4/untitled-ontology-27">http://www.semanticweb.org/yourname/ontologies/2020/4/untitled-ontology-27</a>
Edit the name of the ontology (the part after the last “/” in this
case <cite>untitled-ontology-27</cite>) and change it to something like
<cite>PizzaTutorial</cite>. Note: the Pizza ontology IRIs shown below (e.g.,
figure 4.3) show the IRI after I edited the default that Protégé
generated for me. Your IRI will look different and will be based on
your name or the name of your organization.</p></li>
<li><p>Now you want to save your new ontology. Select <cite>File&gt;Save</cite>. This
should bring up a window that says: <cite>Choose a format to use when
saving the ‘PizzaTutorial’ ontology</cite>. There is a drop down menu of
formats to use. The default <cite>RDF/XML Syntax</cite> should be selected by
clicking the <cite>OK</cite> button. This should bring up the standard dialog your
operating system uses for saving files. Navigate to the folder you
want to use and then type in the file name, something like <cite>Pizza
Tutorial</cite> and select <cite>Save</cite>.</p></li>
</ol>
<hr class="docutils" />
<div class="suggest admonition">
<p class="admonition-title">Tip</p>
<p>As with any file you work on it is a good idea to save your work
at regular intervals so that if something goes wrong you don’t
lose your work. At certain points in the tutorial where saving is
especially important the tutorial will prompt you to do so but it
is a good idea to save your work often, not just when prompted.</p>
</div>
<p>The next step is to set some preferences related to the names of new
entities. Remember than in Protégé any class, individual, object
property, data property, annotation property, or rule is referred to
as an entity. The term name in OWL can actually refer to two
different concepts. It can be the last part of the IRI or it can
refer to the annotation property (usually <code class="docutils literal notranslate"><span class="pre">rdfs:label</span></code>) used to provide
a more user friendly name for the entity. We will discuss this in
more detail below in <a class="reference internal" href="#chap7"><span class="std std-ref">Chapter 7</span></a>. For now, we just want to set the
parameters correctly so that future parts of the tutorial (especially
the section on SPARQL queries) will work appropriately.</p>
<p><strong>Exercise 2: Set the Preferences for New Entities and Rendering</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Go to <cite>File&gt;Preferences</cite> in Protégé. This will bring up a new window
with lots and lots of different tabs. Click on the <cite>New entities</cite> tab.
This will bring up a tab that looks similar to figure 4.1. The top part
of that tab is a box labeled Entity IRI. It should be set with the
parameters as shown in figure 4.1. I.e., <cite>Starts with Active ontology
IRI</cite>. <cite>Followed by #</cite>. <cite>Ends with User supplied name</cite>. If the last parameter
is set to <cite>Auto-generated name</cite> change it to <cite>User supplied name</cite>. That is
the parameter most likely to be different but also check the other two
as well.</p></li>
<li><p>Now select the <cite>Renderer</cite> tab. It should look like figure 4.2. Most
importantly, check that <cite>Entity rendering</cite> is set to <cite>Render by entity IRI
short name (ID)</cite> rather than <cite>Render by annotation property</cite>. Don’t worry
if this doesn’t completely make sense at this point. The issues here are
a bit complex and subtle so we defer them until after you have an
understanding of the basic concepts of what an OWL ontology is. We will
have a discussion of these details below in <a class="reference internal" href="#chap7"><span class="std std-ref">Chapter 7</span></a>. For now you just
need to make sure that the preferences are set appropriately to work
with the rest of the tutorial.</p></li>
</ol>
<hr class="docutils" />
<figure class="align-center align-default" id="id9">
<img alt="_images/11.png" class="no-scaled-link" src="_images/11.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 4.1: The New entities tab</em></span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center align-default" id="id10">
<img alt="_images/21.png" class="no-scaled-link" src="_images/21.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 4.2 Renderer tab</em></span><a class="headerlink" href="#id10" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id10" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center align-default" id="id11">
<img alt="_images/31.png" class="no-scaled-link" src="_images/31.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 4.3: The Active Ontology Tab with a New Comment</em></span><a class="headerlink" href="#id11" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id11" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p><strong>Exercise 3: Add a Comment Annotation to Your Ontology</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Make sure you are in the <cite>Active Ontology</cite> tab. In the view just below
the Ontology IRI and Ontology Version IRI fields find the <cite>Annotations</cite>
option and click on the <cite>+</cite> sign. This will bring up a menu to create a
new annotation on the ontology.</p></li>
<li><p>The <cite>rdfs:comment</cite> annotation should be highlighted by default. If it
isn’t highlighted click on it. Then type a new comment into the view to
the right. Something like <cite>A tutorial ontology for the Pizza domain</cite>.</p></li>
<li><p>Click <cite>OK</cite>. Your Active Ontology tab should like Figure 4.3.</p></li>
</ol>
<hr class="docutils" />
<figure class="align-center align-default" id="id12">
<img alt="_images/4.png" class="no-scaled-link" src="_images/4.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 4.4: The Class Hierarchy View Options</em></span><a class="headerlink" href="#id12" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id12" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<h2 id="named-classes"><span class="sectnum">4.1. </span>Named Classes<a class="headerlink" href="#named-classes" title="Permalink to this heading">¶</a></h2>
<p>The main building blocks of an OWL ontology are classes. In Protégé 5,
editing of classes can be done in the <cite>Entities</cite> tab. The <cite>Entities</cite> tab
has a number of sub-tabs. When you select it, the default should be
the <cite>Class hierarchy</cite> view as shown in Figure 4.5. All empty ontologies
contains one class called <code class="docutils literal notranslate"><span class="pre">owl:Thing</span></code>. OWL classes are sets of
individuals. The class <code class="docutils literal notranslate"><span class="pre">owl:Thing</span></code> is the class that represents the set
containing all individuals. Because of this all classes are subclasses
of <code class="docutils literal notranslate"><span class="pre">owl:Thing</span></code>.</p>
<p><strong>Exercise 4: Create classes: Pizza, PizzaTopping, and PizzaBase</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Navigate to the <cite>Entities</cite> tab with the <cite>Class hierarchy</cite> view selected.
Make sure <cite>owl:Thing</cite> is selected.</p></li>
<li><p>Press the <cite>Add Subclass</cite> icon shown in figure 4.4. This button creates
a new subclass of the selected class. In this case we want to create a
subclass of owl:Thing.</p></li>
<li><p>This should bring up a dialog titled <cite>Create a new class</cite> with a field
for the name of the new class. Type in <cite>Pizza</cite> and then select <cite>OK</cite>.</p></li>
<li><p>Repeat the previous steps to add the classes <code class="docutils literal notranslate"><span class="pre">PizzaTopping</span></code> and
<code class="docutils literal notranslate"><span class="pre">PizzaBase</span></code> ensuring that <code class="docutils literal notranslate"><span class="pre">owl:Thing</span></code> is selected before using the add
subclass icon so that all your classes are subclasses of <code class="docutils literal notranslate"><span class="pre">owl:Thing</span></code>. Your
user interface should now look like figure 4.5. Don’t worry that some of
the classes are highlighted in red. That is because the reasoner hasn’t
run yet. We will address this shortly.</p></li>
</ol>
<hr class="docutils" />
<figure class="align-center align-default" id="id13">
<img alt="_images/5.png" class="no-scaled-link" src="_images/5.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 4.5 The Classes Sub-Tab in the Entities Tab</em></span><a class="headerlink" href="#id13" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id13" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<div class="suggest admonition">
<p class="admonition-title">Tip</p>
<p>There are no mandatory naming conventions for OWL entities. In
<a class="reference internal" href="#chap7"><span class="std std-ref">Chapter 7</span></a>, we will discuss names and labels in more detail. A
best practice is to select one set of naming conventions and then
abide by that convention across your organization. For this
tutorial we will follow the standard where class and individual
names start with a capital letter for each word and do not
contain spaces. This is known as CamelBack notation. For example:
<code class="docutils literal notranslate"><span class="pre">Pizza</span></code>, <code class="docutils literal notranslate"><span class="pre">PizzaTopping</span></code>, etc. Also, we will follow the standard that
class names are always singular rather than plural. E.g., <code class="docutils literal notranslate"><span class="pre">Pizza</span></code>
rather than <code class="docutils literal notranslate"><span class="pre">Pizzas</span></code>, <code class="docutils literal notranslate"><span class="pre">PizzaTopping</span></code> rather than <code class="docutils literal notranslate"><span class="pre">PizzaToppings</span></code>.</p>
</div>
<h2 id="using-a-reasoner"><span class="sectnum">4.2. </span>Using a Reasoner<a class="headerlink" href="#using-a-reasoner" title="Permalink to this heading">¶</a></h2>
<p>You may notice that one or more of your classes is highlighted in red
as in Figure 4.5. This is because we haven’t run the reasoner yet so
Protégé has not been able to verify that our new classes have no
inconsistencies. When just creating classes and subclasses in a new
ontology there is little chance of an inconsistency. However, it is a
good idea to run the reasoner often. When there is an inconsistency
the sooner it is discovered the easier it is to fix. One common
mistake that new users make is to do a lot of development and then run
the reasoner only to find that there are multiple inconsistencies
which can make debugging significantly more difficult. So let’s get
into the good habit of running the reasoner often.</p>
<p>Protégé comes with some reasoners bundled in and others available as
plugins. Since we are going to write some SWRL rules later in the
tutorial, we want to use the Pellet reasoner. It has the best support
for SWRL at the time this tutorial is being written.</p>
<p><strong>Exercise 5: Install and Run the Pellet Reasoner</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Check to see if the Pellet reasoner is installed. Click on the
<cite>Reasoner</cite> menu. At the bottom of the menu there will be a list of the
installed reasoners such as <cite>Hermit</cite> and possibly <cite>Pellet</cite>. If Pellet is
visible in that menu then select it and skip to step 3.</p></li>
<li><p>If Pellet is not visible then do <cite>File&gt;Check for plugins</cite> and select
Pellet from the list of available plugins and then select <cite>Install</cite>. This
will install Pellet and you should get a message that says it will take
effect the next time you start Protégé. Do a <cite>File&gt;Save</cite> to save your work
then quit Protégé and restart it. Then go to <cite>File&gt;Open recent</cite>. You
should see your saved Pizza tutorial in the list of recent ontologies.
Select it to load it. Now you should see Pellet under the <cite>Reasoner</cite> menu
and be able to select it so do so.</p></li>
<li><p>With Pellet selected in the Reasoner menu execute the command
<cite>Reasoner&gt;Start reasoner</cite>. The reasoner should run very quickly since the
ontology is so simple. You will notice that the little text message in
the lower right corner of the Protégé window has changed to now say
<cite>Reasoner active</cite>. The next time you make a change to the ontology that
text will change to say: <cite>Reasoner state out of sync with active
ontology</cite>. With small ontologies the reasoner runs very quickly, and it
is a good idea to get into the habit of running it often, as much as
after every change.</p></li>
<li><p>It is possible that one or more of your classes will still be
highlighted in red after you run the reasoner.
If that happens do: <cite>Window&gt;Refresh user interface</cite> and any red highlights
should go away. Whenever your user interface seems to show something you
don’t expect the first thing to do is to try this command.</p></li>
<li><p>One last thing we want to do is to configure the reasoner. By
default, the reasoner does not perform all possible inferences because
some inferences can take a long time for large and complex ontologies.
In this tutorial we will always be dealing with small and simple
ontologies so we want to see everything the reasoner can do. Go to:
<cite>Reasoner&gt;Configure</cite>. This will bring up a dialog with several check boxes
of inferences that the reasoner can perform. If they aren’t all checked
then check them all. You may receive a warning that some inferences can
take a lot of time, but you can ignore those since your ontology will be
small.</p></li>
</ol>
<hr class="docutils" />
<h2 id="disjoint-classes"><span class="sectnum">4.3. </span>Disjoint Classes<a class="headerlink" href="#disjoint-classes" title="Permalink to this heading">¶</a></h2>
<p>Having added the classes <code class="docutils literal notranslate"><span class="pre">Pizza</span></code>, <code class="docutils literal notranslate"><span class="pre">PizzaTopping</span></code>, and <code class="docutils literal notranslate"><span class="pre">PizzaBase</span></code> to the
ontology, we now want to say that these classes are <em>disjoint</em>. I.e.,
no individual can be an instance of more than one of those classes. In
set theory terminology the intersection of these three classes is the
empty set: <code class="docutils literal notranslate"><span class="pre">owl:Nothing</span></code>.</p>
<p><strong>Exercise 6: Make Pizza, PizzaTopping, and PizzaBase disjoint from each other</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Select the class <cite>Pizza</cite> in the class hierarchy.</p></li>
<li><p>Find the <cite>Disjoint With</cite> option in the <cite>Description</cite> view and select the
<cite>(+)</cite> sign next to it. See the red circle in figure 4.6.</p></li>
<li><p>This should bring up a dialog with two tabs: <cite>Class hierarchy</cite> and
<cite>Expression editor</cite>. You want <cite>Class hierarchy</cite> for now (we will use the
expression editor later). This gives you an interface to select a class
that is identical to the <cite>Class hierarchy</cite> view. Use it to navigate to
<cite>PizzaBase</cite>. Hold down the shift key and select <cite>PizzaBase</cite> and
<cite>PizzaTopping</cite>. Select <cite>OK</cite>.</p></li>
<li><p>Do a <cite>Reasoner&gt;Synchronize reasoner</cite>. Then look at <code class="docutils literal notranslate"><span class="pre">PizzaBase</span></code> and
<code class="docutils literal notranslate"><span class="pre">PizzaTopping</span></code>. You should see that they each have the appropriate
disjoint axioms defined to indicate that each of these classes is
disjoint with the other two.</p></li>
</ol>
<hr class="docutils" />
<figure class="align-center align-default" id="id14">
<img alt="_images/6.png" class="no-scaled-link" src="_images/6.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 4.6: The Disjoint Option in the Class Description View</em></span><a class="headerlink" href="#id14" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id14" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<div class="explain admonition">
<p class="admonition-title">Explanation</p>
<p>OWL classes are assumed to overlap, i.e., by default they are not
disjoint. This is often useful because in OWL, unlike in most
object-oriented models, multiple inheritance is not discouraged
and can be a powerful tool to model data. If we want classes to
be disjoint, we must explicitly declare them to be so. It is
often a good development strategy to start with classes that are
not disjoint and then make them disjoint once the model is more
fully fleshed out as it is not always obvious which classes are
disjoint from the beginning.</p>
</div>
<h2 id="using-create-class-hierarchy"><span class="sectnum">4.4. </span>Using Create Class Hierarchy<a class="headerlink" href="#using-create-class-hierarchy" title="Permalink to this heading">¶</a></h2>
<p>In this section we will use <cite>Tools&gt;Create class hierarchy</cite> to create
multiple classes at once.</p>
<figure class="align-center align-default" id="id15">
<img alt="_images/7.png" class="no-scaled-link" src="_images/7.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 4.7: The Create class hierarchy wizard</em></span><a class="headerlink" href="#id15" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id15" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p><strong>Exercise 7: Use the Create class hierarchy tool to create subclasses of PizzaBase</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Select the class <cite>PizzaBase</cite> in the class hierarchy.</p></li>
<li><p>With <cite>PizzaBase</cite> selected use the <cite>Tools&gt;Create class hierarchy</cite> menu option.</p></li>
<li><p>This should bring up a wizard that enables you to create a nested
group of classes all at once. You should see a window labeled <cite>Enter
hierarchy</cite> where you can enter one name on each line. You can also use
the tab key to indicate that a class is a subclass of the class above
it. For now we just want to enter two subclasses of <code class="docutils literal notranslate"><span class="pre">PizzaBase</span></code>:
<code class="docutils literal notranslate"><span class="pre">ThinAndCrispyBase</span></code> and <code class="docutils literal notranslate"><span class="pre">DeepPanBase</span></code>. One of the things the wizard does is
to automatically add a prefix or suffix for us. So just enter
<cite>ThinAndCrispy</cite>, hit return and enter <cite>DeepPan</cite>. Then in the Suffix field
add <cite>Base</cite>. Your window should look like figure 4.7.</p></li>
<li><p>Select <cite>Continue</cite>. This will take you to a window that asks if you want
to make sibling classes disjoint. The default should be checked (make
them disjoint) which is what we want in this case (a base can’t be both
deep pan and thin) so just select <cite>Finish</cite>. Synchronize the reasoner. Your
class hierarchy should now look like figure 4.8.</p></li>
</ol>
<hr class="docutils" />
<figure class="align-center align-default" id="id16">
<img alt="_images/8.png" class="no-scaled-link" src="_images/8.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 4.8: The New Class Hierarchy</em></span><a class="headerlink" href="#id16" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id16" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<h2 id="create-a-pizzatopping-hierarchy"><span class="sectnum">4.5. </span>Create a PizzaTopping Hierarchy<a class="headerlink" href="#create-a-pizzatopping-hierarchy" title="Permalink to this heading">¶</a></h2>
<p>We will use <cite>Tools&gt;Create class hierarchy</cite> again but this time to create
a more interesting hierarchy with additional subclasses to model the
subclasses of <code class="docutils literal notranslate"><span class="pre">PizzaTopping</span></code>.</p>
<p><strong>Exercise 8: Create subclasses of PizzaTopping</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Select the class <cite>PizzaTopping</cite> in the class hierarchy.</p></li>
<li><p>With <cite>PizzaTopping</cite> selected use the <cite>Tools&gt;Create class hierarchy</cite> menu option.</p></li>
<li><p>This will once again bring up the wizard. We want all our toppings to
end in Topping so enter <cite>Topping</cite> in the Suffix field. Then create the
nested structure as shown in figure 4.9. Use the Tab key to indent
classes where needed.</p></li>
<li><p>Select <cite>Continue</cite>. This will take you to the window that asks if you
want to make sibling classes disjoint. We do want this so leave the box
checked and click <cite>Finish</cite>. Synchronize the reasoner. Your class hierarchy
should now look like figure 4.10.</p></li>
</ol>
<hr class="docutils" />
<figure class="align-center align-default" id="id17">
<img alt="_images/9.png" class="no-scaled-link" src="_images/9.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 4.9 Using Create class hierarchy to create PizzaTopping subclasses</em></span><a class="headerlink" href="#id17" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id17" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center align-default" id="id18">
<img alt="_images/10.png" class="no-scaled-link" src="_images/10.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 4.10 The New PizzaTopping Class Hierarchy</em></span><a class="headerlink" href="#id18" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id18" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<div class="explain admonition">
<p class="admonition-title">Explanation</p>
<p>So far, we have created some simple named classes and
subclasses which hopefully seem intuitive and obvious. However,
what does it actually mean to be a subclass of something in
OWL? For example, what does it mean for <code class="docutils literal notranslate"><span class="pre">VegetableTopping</span></code> to be
a subclass of <code class="docutils literal notranslate"><span class="pre">PizzaTopping</span></code>? In OWL subclass means <em>necessary implication</em>.
I.e., if <code class="docutils literal notranslate"><span class="pre">VegetableTopping</span></code> is a subclass of <code class="docutils literal notranslate"><span class="pre">PizzaTopping</span></code> then
<em>all</em> instances of <code class="docutils literal notranslate"><span class="pre">VegetableTopping</span></code> are also instances of
<code class="docutils literal notranslate"><span class="pre">PizzaTopping</span></code>. It is for this reason that we try to have
standards such as having all
<code class="docutils literal notranslate"><span class="pre">PizzaTopping</span></code> classes end with the word “Topping”. Otherwise, it
might seem we are saying that anything that is a kind of <em>Ham</em>
like the <em>Ham</em> in your sandwich is a kind of <code class="docutils literal notranslate"><span class="pre">MeatTopping</span></code> or
<code class="docutils literal notranslate"><span class="pre">PizzaTopping</span></code> which is not what we mean. For large ontologies
strict attention to the naming of classes and other entities
can prevent potential confusion and bugs.</p>
</div>
<h2 id="owl-properties"><span class="sectnum">4.6. </span>OWL Properties<a class="headerlink" href="#owl-properties" title="Permalink to this heading">¶</a></h2>
<p>OWL Properties represent relationships. There are three types of
properties, Object properties, Data properties and Annotation
properties. Object properties are relationships between two
individuals. Data properties are relations between an individual and a
datatype such as xsd:string or xsd:dateTime.</p>
<p>Annotation properties also usually have datatypes as values although
they can have objects. An
annotation property is usually meta-data such as a comment or a label.
In OWL only individuals can have values for object and data
properties, but any entity can have an annotation property value since
meta-data applies to all entities. Annotation properties usually can’t
be reasoned about. For example, SWRL rules which we will cover later
cannot view or change the value of annotation properties. In this
chapter we will focus on Object properties. Data properties are
described in Chapter 5. In the current version of the tutorial we are
only discussing the annotation property <code class="docutils literal notranslate"><span class="pre">rdfs:label</span></code> (see <a class="reference internal" href="#chap7"><span class="std std-ref">Chapter 7</span></a>)
however they are fairly intuitive.</p>
<p>Properties may be created using the <cite>Object Properties</cite> sub-tab of the
<cite>Entities</cite> tab shown in figure 4.11.</p>
<p>Just as all OWL classes ultimately are a subclass of <code class="docutils literal notranslate"><span class="pre">owl:Thing</span></code>, all
properties are ultimately a sub-property of <code class="docutils literal notranslate"><span class="pre">owl:topObjectProperty</span></code>. A
sub-property is similar to a subclass except it is about the tuples in a
property. For example, <code class="docutils literal notranslate"><span class="pre">hasFather</span></code> would be a sub-property of <code class="docutils literal notranslate"><span class="pre">hasParent</span></code>
because all the tuples in <code class="docutils literal notranslate"><span class="pre">hasFather</span></code> are in <code class="docutils literal notranslate"><span class="pre">hasParent</span></code> but not vice versa.
E.g., if <code class="docutils literal notranslate"><span class="pre">Sasha</span> <span class="pre">hasFather</span> <span class="pre">Barack</span></code> then she also <code class="docutils literal notranslate"><span class="pre">hasParent</span> <span class="pre">Barack</span></code>. However,
she also <code class="docutils literal notranslate"><span class="pre">hasParent</span> <span class="pre">Michelle</span></code> but it is not the case that she
<code class="docutils literal notranslate"><span class="pre">hasFather</span> <span class="pre">Michelle</span></code>. Rather she <code class="docutils literal notranslate"><span class="pre">hasMother</span> <span class="pre">Michelle</span></code>, i.e., <code class="docutils literal notranslate"><span class="pre">hasMother</span></code> is also
a sub-property of <code class="docutils literal notranslate"><span class="pre">hasParent</span></code>.</p>
<p>The GUI for entering properties is also similar to that for entering
classes. The first icon with one box under another creates a
sub-property of the selected property. The second icon showing two boxes
at the same level creates a sibling property to the selected property
and the icon with an <cite>X</cite> through a box deletes the selected property.</p>
<p><strong>Exercise 9: Create some properties</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Select the Object properties sub-tab of the Entities tab (see figure 4.11).</p></li>
<li><p>Make sure <code class="docutils literal notranslate"><span class="pre">owl:topObjectProperty</span></code> is selected<strong>.</strong> Click on the nested
box icon at the left to create a new sub-property of
<code class="docutils literal notranslate"><span class="pre">owl:topObjectProperty</span></code>. When prompted for the name of the new property
type in <cite>hasIngredient</cite>.</p></li>
<li><p>Just as you can use a wizard to create multiple classes you can also
use one to create multiple properties. Select <cite>hasIngredient</cite> and then
select <cite>Tools&gt;Create object property hierarchy</cite>. Enter the new property
names <cite>hasTopping</cite> and <cite>hasBase</cite>. Select Continue and accept the default
that the object properties are <em>not</em> disjoint.</p></li>
<li><p>Synchronize the reasoner. Your window should now look like figure 4.11.</p></li>
</ol>
<hr class="docutils" />
<div class="explain admonition">
<p class="admonition-title">Explanation</p>
<p>For those familiar with the Entity-Relationship model, OWL object
properties are similar to relations and data properties are
similar to attributes. Object properties are similar to
properties with a range of some class in OOP and data properties
are similar to OOP properties with a range that is a datatype.</p>
</div>
<figure class="align-center align-default" id="id19">
<img alt="_images/111.png" class="no-scaled-link" src="_images/111.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 4.11 Adding Some Object Properties</em></span><a class="headerlink" href="#id19" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id19" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<h2 id="inverse-properties"><span class="sectnum">4.7. </span>Inverse Properties<a class="headerlink" href="#inverse-properties" title="Permalink to this heading">¶</a></h2>
<p>Each object property may have a corresponding inverse property. If
some property links individual a to individual b then its inverse
property will link individual b to individual a. For example, in
figure 3.3 the individual <code class="docutils literal notranslate"><span class="pre">MichaelhasPetBuddy</span></code>. In this example <code class="docutils literal notranslate"><span class="pre">hasPet</span></code>
is an object property that maps from a <code class="docutils literal notranslate"><span class="pre">Person</span></code> to their <code class="docutils literal notranslate"><span class="pre">Pet</span></code> which are
known as the domain and range of the property. <code class="docutils literal notranslate"><span class="pre">Michael</span></code> is an instance
of the <code class="docutils literal notranslate"><span class="pre">Person</span></code> class and <code class="docutils literal notranslate"><span class="pre">Buddy</span></code> is an instance of the <code class="docutils literal notranslate"><span class="pre">Pet</span></code> class. The
<code class="docutils literal notranslate"><span class="pre">hasPet</span></code> property points from a <code class="docutils literal notranslate"><span class="pre">Person</span></code> to that person’s <code class="docutils literal notranslate"><span class="pre">Pet</span></code>. The inverse
property could be <code class="docutils literal notranslate"><span class="pre">isPetOf</span></code> which would be represented by a link between
the two individuals going the other way, from <code class="docutils literal notranslate"><span class="pre">Buddy</span></code> to <code class="docutils literal notranslate"><span class="pre">Michael</span></code>.
Whenever possible it is desirable to adhere to this type of naming
standard with properties. Properties going in one direction as
<em>hasProperty</em> and their inverses as <em>isPropertyOf</em>.</p>
<p><strong>Exercise 10: Create some inverse properties</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Use the <cite>Object properties</cite> tab to create a new object property called
<code class="docutils literal notranslate"><span class="pre">isIngredientOf</span></code> (this will be the inverse property of <code class="docutils literal notranslate"><span class="pre">hasIngredient</span></code>).
Make sure that <code class="docutils literal notranslate"><span class="pre">isIngredientOf</span></code> is a sibling property if <code class="docutils literal notranslate"><span class="pre">hasIngredient</span></code> and
a sub-property of <code class="docutils literal notranslate"><span class="pre">owl:topObjectProperty</span></code>.</p></li>
<li><p>Click on the Add icon <cite>(+)</cite> next to <cite>Inverse Of</cite> in the <cite>Description</cite> view
for <code class="docutils literal notranslate"><span class="pre">hasIngredient</span></code>. You will be presented with a window that shows a
nested view of all the current properties. Select <cite>hasIngredient</cite> to make
it the inverse of <code class="docutils literal notranslate"><span class="pre">isIngredientOf</span></code>.</p></li>
<li><p>Select <cite>isIngredientOf</cite> and then <cite>Tools&gt;Create object property
hierarchy</cite>. Enter <cite>isToppingOf</cite> then on a new line enter <cite>isBaseOf</cite>. As
before, select <cite>Continue</cite> and leave the box for disjoint properties
unchecked and select <cite>Finish</cite>. Repeat step 2 to make <code class="docutils literal notranslate"><span class="pre">isToppingOf</span></code> the
inverse of <code class="docutils literal notranslate"><span class="pre">hasTopping</span></code> and <code class="docutils literal notranslate"><span class="pre">isBaseOf</span></code> the inverse of <code class="docutils literal notranslate"><span class="pre">hasBase</span></code>.</p></li>
<li><p>Synchronize the reasoner. Your window should now look like figure 4.12.</p></li>
</ol>
<figure class="align-center align-default" id="id20">
<img alt="_images/12.png" class="no-scaled-link" src="_images/12.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 4.12 Inverse Properties</em></span><a class="headerlink" href="#id20" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id20" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<h2 id="owl-object-property-characteristics"><span class="sectnum">4.8. </span>OWL Object Property Characteristics<a class="headerlink" href="#owl-object-property-characteristics" title="Permalink to this heading">¶</a></h2>
<p>OWL allows the meaning of properties to be enriched through the use of
property characteristics. The following sections discuss the various
characteristics that properties may have. If you are familiar with
basic concepts of relations in set theory these characteristics will
already be familiar to you. In figure 4.12 you can see the
<cite>Characteristics</cite>: view for a property as a list of check boxes:
<cite>Functional</cite>, <cite>Inverse functional</cite>, <cite>Transitive</cite>, etc.</p>
<h3 id="functional-properties"><span class="sectnum">4.8.1. </span>Functional Properties<a class="headerlink" href="#functional-properties" title="Permalink to this heading">¶</a></h3>
<p>If a property is functional, for a given individual, there can be at
most one individual that is related to the individual via the
property. For example the property <code class="docutils literal notranslate"><span class="pre">hasBirthMother</span></code> – someone can only
have one birth mother. If we say that the individual
<code class="docutils literal notranslate"><span class="pre">Jean</span> <span class="pre">hasBirthMother</span> <span class="pre">Peggy</span></code> and we also say that the individual
<code class="docutils literal notranslate"><span class="pre">Jean</span> <span class="pre">hasBirthMother</span> <span class="pre">Margaret</span></code>, then because <code class="docutils literal notranslate"><span class="pre">hasBirthMother</span></code> is a
functional property, we can infer that <code class="docutils literal notranslate"><span class="pre">Peggy</span></code> and <code class="docutils literal notranslate"><span class="pre">Margaret</span></code> must be the
same individual. This can happen in OWL because unlike many languages it does not have a unique names assumption. Unless
specifically stated otherwise, the reasoner can infer that two
individuals with different names are actually the same individual. It
should be noted however, that if <code class="docutils literal notranslate"><span class="pre">Peggy</span></code> and <code class="docutils literal notranslate"><span class="pre">Margaret</span></code> were explicitly
stated to be two diﬀerent individuals then the above statements would
lead the reasoner to infer that there was an inconsistency in the
ontology. We will discuss names more in <a class="reference internal" href="#chap7"><span class="std std-ref">Chapter 7</span></a>.</p>
<p>In <a class="reference external" href="#cardinality-restrictions">section 4.16</a> we will discuss cardinality restrictions on properties.
E.g., that the <code class="docutils literal notranslate"><span class="pre">hasWheel</span></code> property of the <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> class has a minimum of 2
(allowing for training wheels) whereas <code class="docutils literal notranslate"><span class="pre">hasWheel</span></code> for the <code class="docutils literal notranslate"><span class="pre">Unicycle</span></code> class
is defined to be exactly 1. A functional property is equivalent to a
property with a cardinality restriction that says it has a maximum of 1
value. The term functional is from mathematics where a function is
defined as a relation where each member of the domain has at most one
value. For example, the <code class="docutils literal notranslate"><span class="pre">greaterThan</span></code> relation is not functional since for
any number <code class="docutils literal notranslate"><span class="pre">X</span></code> many (in fact an infinite number) can be <code class="docutils literal notranslate"><span class="pre">greaterThan</span></code> <code class="docutils literal notranslate"><span class="pre">X</span></code> but
the <code class="docutils literal notranslate"><span class="pre">plusOne</span></code> relation is functional since for any number <code class="docutils literal notranslate"><span class="pre">X</span></code> <code class="docutils literal notranslate"><span class="pre">plusOne</span></code> always
results in one unique value.</p>
<h3 id="inverse-functional-properties"><span class="sectnum">4.8.2. </span>Inverse Functional Properties<a class="headerlink" href="#inverse-functional-properties" title="Permalink to this heading">¶</a></h3>
<p>If a property is inverse functional then it means that the inverse
property is functional. For a given individual, there can be at most
one individual related to that individual via the property. Following
our example from <a class="reference external" href="#functional-properties">section 4.8.1</a> the inverse of <code class="docutils literal notranslate"><span class="pre">hasBirthMother</span></code> would be
<code class="docutils literal notranslate"><span class="pre">isBirthMotherOf</span></code>. The <code class="docutils literal notranslate"><span class="pre">isBirthMotherOf</span></code> property would not be functional
since a woman can be the birth mother of several children. However, it
would be inverse functional since each person has exactly one mother.</p>
<h3 id="transitive-properties"><span class="sectnum">4.8.3. </span>Transitive Properties<a class="headerlink" href="#transitive-properties" title="Permalink to this heading">¶</a></h3>
<table class="docutils data align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td rowspan="3"><p><img alt="trans_prop_img" class="no-scaled-link" src="_images/13.png" /></p>
<p class="centered">
<strong><em>Figure 4.13 Transitive Properties</em></strong></p></td>
<td><p>If a property P is transitive, and P relates individual a to individual b,
individual b, and also individual b to individual c, then we can infer that
individual a is related to individual c via property P.</p>
<p>For example, Figure 4.13 shows an example of the transitive property
<code class="docutils literal notranslate"><span class="pre">hasAncestor</span></code>. If the individual <code class="docutils literal notranslate"><span class="pre">Diya</span></code> has an ancestor that is <code class="docutils literal notranslate"><span class="pre">Fatima</span></code>
, and <code class="docutils literal notranslate"><span class="pre">Fatima</span></code> has an ancestor that is <code class="docutils literal notranslate"><span class="pre">Arjun</span></code>, then we can infer that
<code class="docutils literal notranslate"><span class="pre">Diya</span></code> has an ancestor that is <code class="docutils literal notranslate"><span class="pre">Arjun</span></code> – this is indicated by the curved
line in Figure 4.13.</p>
</td>
</tr>
<tr class="row-even"><td><p>An example of the transitive property in mathematics is the <em>&gt;</em> relation.
If x &gt; y and y &gt; z then x &gt; z.</p></td>
</tr>
<tr class="row-odd"><td><p>Note that if a property is transitive it cannot be functional. Also,
if a property is transitive then its inverse property must also be
transitive. E.g., the inverse of &gt; is &lt; and &lt; is also transitive. We
will see an example of this in <a class="reference internal" href="#chap6"><span class="std std-ref">Chapter 6</span></a>.</p></td>
</tr>
</tbody>
</table>
<h3 id="symmetric-and-asymmetric-properties"><span class="sectnum">4.8.4. </span>Symmetric and Asymmetric Properties<a class="headerlink" href="#symmetric-and-asymmetric-properties" title="Permalink to this heading">¶</a></h3>
<p>If a property P is symmetric, and the property relates individual a to
individual b then individual b is also related to individual a via
property P. The <code class="docutils literal notranslate"><span class="pre">hasSibling</span></code> property or <code class="docutils literal notranslate"><span class="pre">hasSpouse</span></code> are examples of symmetric properties.
If <code class="docutils literal notranslate"><span class="pre">Michelle</span> <span class="pre">hasSpouse</span> <span class="pre">Barack</span></code>, then
<code class="docutils literal notranslate"><span class="pre">Barack</span> <span class="pre">hasSpouse</span> <span class="pre">Michelle</span></code>. A symmetric property is its own inverse.</p>
<p>An asymmetric property is a property that can never have symmetric
values. If a property P is asymmetric then if a is related to b via that property b cannot be
related to a via that property. An example of an asymmetric property
is <code class="docutils literal notranslate"><span class="pre">hasBirthMother</span></code>. If <code class="docutils literal notranslate"><span class="pre">Diya</span> <span class="pre">hasBirthMother</span> <span class="pre">Fatima</span></code>, then it can’t be the
case that <code class="docutils literal notranslate"><span class="pre">Fatima</span> <span class="pre">hasBirthMother</span> <span class="pre">Diya</span></code>.</p>
<h3 id="reflexive-and-irreflexive-properties"><span class="sectnum">4.8.5. </span>Reflexive and Irreflexive Properties<a class="headerlink" href="#reflexive-and-irreflexive-properties" title="Permalink to this heading">¶</a></h3>
<p>A reflexive property is a property that always relates an individual
to itself. If a property P is reflexive then for all individuals a P
will always relate a to a. Equality is the most common example of a
reflexive property. For any object a, a is always equal to a. An
irreflexive property is… you guessed it… a property that can never
relate an individual to itself. The property <code class="docutils literal notranslate"><span class="pre">hasBirthMother</span></code> is an
example of an irreflexive property since no person can be their own
mother. You should use reflexive properties with care.
The domain of a reflexive property is <em>always</em> <code class="docutils literal notranslate"><span class="pre">owl:Thing</span></code>. The reasons are
complex, see the W3C Owl 2 Specification in the bibliography for more
details. The important thing is that if you make a property reflexive
that means its domain is <code class="docutils literal notranslate"><span class="pre">owl:Thing</span></code>. For example, if you have a
reflexive property and declare its domain to be some class such as
<code class="docutils literal notranslate"><span class="pre">Person</span></code> the reasoner will infer that <code class="docutils literal notranslate"><span class="pre">Person</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">owl:Thing</span></code>
which can cause problems.</p>
<h3 id="reasoners-automatically-enforce-property-characteristics"><span class="sectnum">4.8.6. </span>Reasoners Automatically Enforce Property Characteristics<a class="headerlink" href="#reasoners-automatically-enforce-property-characteristics" title="Permalink to this heading">¶</a></h3>
<p>The reasoners that work with Protégé automatically enforce all the
characteristics that are described above. For example, if the user
enters the fact that <code class="docutils literal notranslate"><span class="pre">Diya</span> <span class="pre">hasBirthMother</span> <span class="pre">Fatima</span></code> and <code class="docutils literal notranslate"><span class="pre">isBirthMotherOf</span></code>
is the inverse of <code class="docutils literal notranslate"><span class="pre">hasBirthMother</span></code>, the reasoner will
infer that <code class="docutils literal notranslate"><span class="pre">Fatima</span> <span class="pre">isBirthMotherOf</span> <span class="pre">Diya</span></code>. These types of characteristics
can significantly reduce the amount of effort needed to populate an
ontology with data about individuals.</p>
<h2 id="owl-property-domains-and-ranges"><span class="sectnum">4.9. </span>OWL Property Domains and Ranges<a class="headerlink" href="#owl-property-domains-and-ranges" title="Permalink to this heading">¶</a></h2>
<p>Properties may have a <em>domain</em> and <em>range</em> defined. These terms have
the same meaning in OWL as they do in mathematics and set theory. The
domain of a property is the set of all objects that can have that
property asserted about it. The range is the set of all objects that
can be the value of the property. Both the domain and range are
optional. In general, it is a good idea to define them because doing
so can catch modeling mistakes while defining the model rather than at
run time when trying to use it.
The domain for an object property must
always be a class. For data properties the range is a simple datatype
such as <code class="docutils literal notranslate"><span class="pre">xsd:decimal</span></code>. The most common predefined datatypes already
exist in Protégé. It is also possible to define new data types
although most users will seldom need to do that. For most cases if you
are considering defining a new datatype you should probably consider
making the property an object property instead and defining a class as
the range. For people familiar with Entity-Relation modeling an object
property is similar to a relation and a data property is similar to an
attribute. For those familiar with set theory a property is identical
to a binary relation in set theory.</p>
<p>As an example, in our pizza ontology, the property <code class="docutils literal notranslate"><span class="pre">hasTopping</span></code> would link
individuals belonging to the class <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> to individuals belonging to the
class <code class="docutils literal notranslate"><span class="pre">PizzaTopping</span></code>. The domain of <code class="docutils literal notranslate"><span class="pre">hasTopping</span></code> is <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> and the range is
<code class="docutils literal notranslate"><span class="pre">PizzaTopping</span></code>. Inverse properties have their domains and range swapped.
In this example, the inverse of <code class="docutils literal notranslate"><span class="pre">hasTopping</span></code> will be called <code class="docutils literal notranslate"><span class="pre">isToppingOf</span></code>.
Thus, the domain for <code class="docutils literal notranslate"><span class="pre">isToppingOf</span></code> is the range of <code class="docutils literal notranslate"><span class="pre">hasTopping</span></code>
(<code class="docutils literal notranslate"><span class="pre">PizzaTopping</span></code>) and the range for <code class="docutils literal notranslate"><span class="pre">isToppingOf</span></code> is the domain of <code class="docutils literal notranslate"><span class="pre">hasTopping</span></code>
(<code class="docutils literal notranslate"><span class="pre">Pizza</span></code>).</p>
<p><strong>Exercise 11: Define the domain and range of the hasTopping property</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Navigate to the <cite>Object properties</cite> tab. Select the <cite>hasTopping</cite> property.</p></li>
<li><p>Click on the Add icon <cite>(+)</cite> next to <cite>Domains (intersection)</cite> in the
<cite>Description</cite> view for <code class="docutils literal notranslate"><span class="pre">hasTopping</span></code>. You will be presented with a window
that shows several tabs. There are multiple ways to define domain and
range. For now we will use the simplest method (and the one most often
used). Select the <cite>ClassHierarchy</cite> tab. Then select <cite>Pizza</cite> from the class hierarchy. Your
UI should look like figure 4.14. Click on <cite>OK</cite>. You should now see <cite>Pizza</cite>
underneath the <cite>Domains</cite> in the <cite>Description</cite> view.</p></li>
<li><p>Repeat step 2 but this time start by using the <cite>(+)</cite> icon next to the
<cite>Ranges (intersection)</cite> in the <cite>Description</cite> for <code class="docutils literal notranslate"><span class="pre">hasTopping</span></code>. This time
select the class <cite>PizzaTopping</cite> as the range.</p></li>
<li><p>Synchronize the reasoner. Now select <cite>isToppingOf</cite>. You should see that
the Domain and Range for <code class="docutils literal notranslate"><span class="pre">isToppingOf</span></code> have been filled in by the reasoner
(see figure 4.15). Since the two properties are inverses the reasoner
knows that the domain for one is the range for the other and vice versa.
This is another example of why frequently running the reasoner can save
time and help maintain a valid model. Note that these values are
highlighted in yellow. Any information supplied by the reasoner rather
than by the user is highlighted in this way.</p></li>
</ol>
<hr class="docutils" />
<figure class="align-center align-default" id="id21">
<img alt="_images/14.png" class="no-scaled-link" src="_images/14.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 4.14 Defining the Domain for hasTopping</em></span><a class="headerlink" href="#id21" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id21" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center align-default" id="id22">
<img alt="_images/15.png" class="no-scaled-link" src="_images/15.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 4.15 Domain and Range inferred by the reasoner</em></span><a class="headerlink" href="#id22" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id22" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<div class="pitfall admonition">
<p class="admonition-title">Warning</p>
<p>It is possible to specify more than one class as the domain or
range of a property. One of the most common mistakes of new
users is to do this and expect that the resulting domain/range
is the union of the two classes. However, note that next to the
<cite>Domain</cite> and <cite>Range</cite> in the
<cite>Description</cite> view it says (<cite>intersection</cite>). This is because the
semantics of having 2 or more classes as the domain or range is
the <em>intersection</em> of those classes <em>not</em> the union. E.g., if
one defined the domain for a property to be <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> and then
added another domain <code class="docutils literal notranslate"><span class="pre">IceCream</span></code> that would mean that for
something to be in the domain of that property it would have to
be an instance of <em>both</em> <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> <em>and</em> <code class="docutils literal notranslate"><span class="pre">IceCream</span></code> not (as people
often expect) the <em>union</em> of those two sets which would be
<em>either</em> the class <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> <em>or</em> the class <code class="docutils literal notranslate"><span class="pre">IceCream</span></code>. Also, note
that the domain and range are for inferencing, they are not
data integrity constraints. This distinction will be explained
in more detail below in the section on SHACL.</p>
</div>
<p><strong>Exercise 12: Define the domain and range for the hasBase property</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Now we are going to repeat the same activities as in the previous
exercise but for another property: <code class="docutils literal notranslate"><span class="pre">hasBase</span></code>. Make sure you are still on
the <cite>Object properties</cite> tab. Select the <cite>hasBase</cite> property.</p></li>
<li><p>Click on the Add icon <cite>(+)</cite> next to <cite>Domains (intersection)</cite> in the
<cite>Description</cite> view for <code class="docutils literal notranslate"><span class="pre">hasBase</span></code>. Select the <cite>ClassHierarchy</cite> tab. Then select
<cite>Pizza</cite> from the class hierarchy.</p></li>
<li><p>Repeat step 2 but this time start by using the <cite>(+)</cite> icon next to the
<cite>Ranges (intersection)</cite> in the <cite>Description</cite> for hasBase. This time select
the class <cite>PizzaBase</cite> as the range.</p></li>
</ol>
<p>4. Synchronize the reasoner. Now select <cite>isBaseOf</cite> You should see that the
Domain and Range for <code class="docutils literal notranslate"><span class="pre">isBaseOf</span></code> have been filled in by the reasoner.</p>
<hr class="docutils" />
<h2 id="describing-and-defining-classes"><span class="sectnum">4.10. </span>Describing and Defining Classes<a class="headerlink" href="#describing-and-defining-classes" title="Permalink to this heading">¶</a></h2>
<p>Now that we have defined some properties, we can use these properties
to define some more interesting classes. There are 3 types of classes
in OWL:</p>
<ol class="arabic simple">
<li><p>Primitive classes. These are classes that are defined by conditions
that are <em>necessary</em> (but not sufficient) to hold for any individuals
that are instances of that class or its subclasses. The condition may
be as simple as: <em>Class A is a subclass of class B</em>. To start with we
will define primitive classes first and then defined classes. When
the reasoner encounters an individual that is an instance of a
primitive class it infers that all the conditions defined for that
class must hold for that individual.</p></li>
<li><p>Defined classes. These are classes that are defined by both
<em>necessary</em> and <em>sufficient</em> conditions.
When the reasoner encounters an individual that satisfies all the
conditions for a defined class it will make the inference that the
individual is an instance of that class. The reasoner can also use
the conditions defined on classes to change the class hierarchy,
e.g., to infer that <em>Class A is a subclass of Class B</em>. We will see
examples of this later in the tutorial.</p></li>
<li><p>Anonymous classes. These are classes that you won’t encounter much
and that won’t be discussed much in this tutorial, but it is good to
know about them. They are created by the reasoner when you use class
expressions. For example, if you define the range of a property to be
<code class="docutils literal notranslate"><span class="pre">PizzaTopping</span></code> or <code class="docutils literal notranslate"><span class="pre">PizzaBase</span></code> then the reasoner will create an anonymous
class representing the intersection of those two classes.</p></li>
</ol>
<h3 id="property-restrictions"><span class="sectnum">4.10.1. </span>Property restrictions<a class="headerlink" href="#property-restrictions" title="Permalink to this heading">¶</a></h3>
<p>In OWL properties define binary relations with the same semantics and
characteristics as binary relations in First Order Logic. There are
two types of OWL properties for describing a domain: Object properties
and Data properties. Object properties have classes as their domain
and range. Data properties have classes as their domain and simple
datatypes such as <code class="docutils literal notranslate"><span class="pre">xsd:string</span></code> or <code class="docutils literal notranslate"><span class="pre">xsd:dateTime</span></code> as their range. In figure
3.3 the individual <code class="docutils literal notranslate"><span class="pre">Michael</span></code> is related to the individual <code class="docutils literal notranslate"><span class="pre">USA</span></code> by the
property <code class="docutils literal notranslate"><span class="pre">livesIn</span></code>. Consider all the individuals who are an instance of
<code class="docutils literal notranslate"><span class="pre">Person</span></code> and also have the same relation, that each <code class="docutils literal notranslate"><span class="pre">livesIn</span></code> the <code class="docutils literal notranslate"><span class="pre">USA</span></code>.
This group is a set or OWL class such as <code class="docutils literal notranslate"><span class="pre">USAResidents</span></code>. In OWL a class
can be defined by describing the various properties and values that
hold for all individuals in the class. Such definitions are called
<em>restrictions</em> in OWL.</p>
<p>The following are some examples of classes of individuals that we might
want to define via property restrictions:</p>
<ul class="simple">
<li><p>The class of individuals with at least one <code class="docutils literal notranslate"><span class="pre">hasChild</span></code> relation.</p></li>
<li><p>The class of individuals with 2 or more <code class="docutils literal notranslate"><span class="pre">hasChild</span></code> relations.</p></li>
<li><p>The class of individuals that have at least one <code class="docutils literal notranslate"><span class="pre">hasTopping</span></code> relationship to individuals that are  members of <code class="docutils literal notranslate"><span class="pre">MozzarellaTopping</span></code> – i.e. the class of things that have at least a mozzarella topping.</p></li>
<li><p>The class of individuals that are <code class="docutils literal notranslate"><span class="pre">Pizzas</span></code> and only have <code class="docutils literal notranslate"><span class="pre">hasTopping</span></code> relations to instances of the class <code class="docutils literal notranslate"><span class="pre">VegetableTopping</span></code> (i.e., <code class="docutils literal notranslate"><span class="pre">VegetarianPizza</span></code>).</p></li>
</ul>
<p>In OWL we can describe all of the above classes using restrictions. OWL
restrictions fall into three main categories:</p>
<ol class="arabic simple">
<li><p>Quantifier restrictions. These describe that a property must have some or all values that are of a particular class.</p></li>
<li><p>Cardinality restrictions. These describe the number of individuals that must be related to a class by a specific property.</p></li>
<li><p>hasValue restrictions. These describe specific values that a property must have.</p></li>
</ol>
<p>We will initially use quantifier restrictions. Quantifier restrictions
can be further categorized as <em>existential</em> restrictions and <em>universal</em>
restrictions6. Both types of restrictions will be illustrated with
examples in this tutorial.</p>
<ul class="simple">
<li><p>Existential restrictions describe classes of individuals that
participate in at least one relation along
a specified property. For example, the class of individuals
who have at least one (or some)
<code class="docutils literal notranslate"><span class="pre">hasTopping</span></code> relation to instances of <code class="docutils literal notranslate"><span class="pre">VegetableTopping</span></code>. In OWL
the keyword some is used to denote existential restrictions.</p></li>
<li><p>Universal restrictions describe classes of individuals that
for a given property <em>only</em> have relations
along a property to individuals that are members of a
specific class. For example, the class of
individuals that only have <code class="docutils literal notranslate"><span class="pre">hasTopping</span></code> relations to instances of the class <code class="docutils literal notranslate"><span class="pre">VegetableTopping</span></code>.
In OWL they keyword only is used for universal restrictions.</p></li>
</ul>
<p>Let’s take a closer look at an example of an existential restriction.
The restriction <code class="docutils literal notranslate"><span class="pre">hasTopping</span> <span class="pre">some</span> <span class="pre">MozzarellaTopping</span></code> is an existential
restriction (as indicated by the some keyword), which restricts the
<code class="docutils literal notranslate"><span class="pre">hasTopping</span></code> property, and has a filler <code class="docutils literal notranslate"><span class="pre">MozzarellaTopping</span></code>. This
restriction describes the class of individuals that have at least one
<code class="docutils literal notranslate"><span class="pre">hasTopping</span></code> relationship to an individual that is a member of the class
<code class="docutils literal notranslate"><span class="pre">MozzarellaTopping</span></code>.</p>
<div class="vocab admonition">
<p class="admonition-title">Vocab</p>
<p>A restriction always describes a class. Sometimes (as we will soon
see) it can be a defined class.
Other times it may be an anonymous class. In all cases the class
contains all of the individuals that satisfy the restriction,
i.e., all of the individuals that have the relationships required
to be a member of the class. In <a class="reference external" href="#sparql-queries">section 9.2</a> one of our SPARQL
queries will return several anonymous classes.</p>
</div>
<p>The restrictions for a class are displayed and edited using the <cite>Class
Description View</cite> shown in Figure 4.17. The Class Description View holds
most of the information used to describe a class. The Class Description
View is a powerful way of describing and defining classes. It is one of
the most important differences between describing classes in OWL and in
other models such as most object-oriented programming languages. In
other models there is no formal definition that describes why one class
is a subclass of another, in OWL there is. Indeed, the OWL classifier
can actually redefine the class hierarchy based on the logical
restrictions defined by the user. We will see an example of this later
in the tutorial.</p>
<div class="vocab admonition">
<p class="admonition-title">Vocab</p>
<p>Restrictions are also called axioms in OWL. This has the same
meaning as in logic. An axiom is a logical formula defined by the
user rather than deduced by the reasoner. As described above, in
Protégé all axioms are shown in normal font whereas all
inferences inferred by the reasoner are highlighted in yellow.</p>
</div>
<h3 id="existential-restrictions"><span class="sectnum">4.10.2. </span>Existential Restrictions<a class="headerlink" href="#existential-restrictions" title="Permalink to this heading">¶</a></h3>
<p>An existential restriction describes a class of individuals that have
at least one (some) relationship along a specified property to an
individual that is a member of a specified class or datatype. For
example, <code class="docutils literal notranslate"><span class="pre">hasBase</span> <span class="pre">some</span> <span class="pre">PizzaBase</span></code> describes all of the individuals that
have at least one relationship along the hasBase property to an
individual that is a member of the class <code class="docutils literal notranslate"><span class="pre">PizzaBase</span></code> — in more natural
English, all of the individuals that have at least one pizza base.</p>
<p><strong>Exercise 13: Add a restriction to Pizza that specifies a Pizza must have a PizzaBase</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Select <cite>Pizza</cite> from the class hierarchy on the <cite>Classes</cite> tab.</p></li>
<li><p>Click on the Add icon <cite>(+)</cite> next to the <cite>SubClass Of</cite> field in the
<cite>Description</cite> view for Pizza.</p></li>
<li><p>This will bring up a new window with several tab options to define a
new restriction. Select the <cite>Object restriction creator</cite>. This tab has the
<cite>Restricted property</cite> on the left and the <cite>Restriction filler</cite> on the right.</p></li>
<li><p>Expand the property hierarchy on the left and select <cite>hasBase</cite> as the
property to restrict. Then in the Restriction filler on the right select
the class <cite>PizzaBase</cite>. Finally, the Restriction type at the bottom should
be set to <cite>Some (existential)</cite>. This should be the default so you
shouldn’t have to change anything but double check that this is the
case. Your window should look like figure 4.16 now.</p></li>
<li><p>When your UI looks like figure 4.16 click on the <cite>OK</cite> button. That
should close the window. Run the reasoner to make sure things are
consistent. Your main window should now look like figure 4.17.</p></li>
</ol>
<hr class="docutils" />
<figure class="align-center align-default" id="id23">
<img alt="_images/16.png" class="no-scaled-link" src="_images/16.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 4.16 The Object Restriction Creator Tab</em></span><a class="headerlink" href="#id23" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id23" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center align-default" id="id24">
<img alt="_images/17.png" class="no-scaled-link" src="_images/17.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 4.17 The Pizza Class with hasBase Restriction</em></span><a class="headerlink" href="#id24" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id24" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>We have described the class <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> to be to be a subclass of <code class="docutils literal notranslate"><span class="pre">Thing</span></code> and a
subclass of the things that have a base which is some kind of <code class="docutils literal notranslate"><span class="pre">PizzaBase</span></code>.
Notice that these are necessary conditions — if something is a <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> it
is <em>necessary</em> for it to be a member of the class <code class="docutils literal notranslate"><span class="pre">Thing</span></code> (in OWL,
everything is a member of the class Thing) and <em>necessary</em> for it to
have a kind of <code class="docutils literal notranslate"><span class="pre">PizzaBase</span></code>. More formally, for something to be a <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> it
is necessary for it to be in a relationship with an individual that is a
member of the class <code class="docutils literal notranslate"><span class="pre">PizzaBase</span></code> via the property <code class="docutils literal notranslate"><span class="pre">hasBase</span></code>.</p>
<h3 id="creating-subclasses-of-pizza"><span class="sectnum">4.10.3. </span>Creating Subclasses of Pizza<a class="headerlink" href="#creating-subclasses-of-pizza" title="Permalink to this heading">¶</a></h3>
<p>It’s now time to add some different kinds of pizzas to our ontology.
We will start off by adding a <code class="docutils literal notranslate"><span class="pre">MargheritaPizza</span></code>, which is a pizza that
has toppings of mozzarella and tomato. In order to keep our ontology
tidy, we will group our different pizzas under the class <code class="docutils literal notranslate"><span class="pre">NamedPizza</span></code>.</p>
<p><strong>Exercise 14: Create Subclasses of Pizza: NamedPizza and MargheritaPizza</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Select <cite>Pizza</cite> from the class hierarchy on the <cite>Classes</cite> tab.</p></li>
<li><p>Click on the Add subclass icon at the top left of the Classes tab
(look back at figure 4.4 if you aren’t certain). You can also move your
mouse over the icons and you will see a little pop-up hint for each
icon.</p></li>
<li><p>Protégé will prompt you for the name of the new subclass. Call it <cite>NamedPizza</cite>.</p></li>
<li><p>Repeat steps 1-3 this time starting with <cite>NamedPizza</cite> to create a
subclass of <cite>NamedPizza</cite>. Call it MargheritaPizza.</p></li>
<li><p>Add a comment to the class MargheritaPizza using the <cite>Annotations</cite>
view. This is above the <cite>Description</cite> view. Add the comment:
<cite>A pizza that only has Mozzarella and Tomato toppings</cite>. Remember that annotation
properties are meta-data that can be asserted about any entity whereas
object and data properties can only be asserted about individuals. There
are a few predefined annotation properties that are included in all
Protégé ontologies such as the comment property.</p></li>
</ol>
<hr class="docutils" />
<p>Having created the class MargheritaPizza we now need to specify the
toppings that it has. To do this we will add two restrictions to say
that a MargheritaPizza has the toppings <cite>MozzarellaTopping</cite> and
<cite>TomatoTopping</cite>.</p>
<p><strong>Exercise 15: Create Restrictions that define a MargheritaPizza</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Select <cite>MargheritaPizza</cite> from the class hierarchy on the <cite>Classes</cite> tab.</p></li>
<li><p>Click on the Add icon <cite>(+)</cite> next to the <cite>SubClass Of</cite> field in the
<cite>Description</cite> view for <cite>Pizza</cite>.</p></li>
<li><p>This again brings up the restriction dialogue. This time rather than
use the <cite>Object restriction creator</cite> we will use the <cite>Class expression editor</cite> tab.
Select that tab.</p></li>
<li><p>Type <cite>hasTopping some Mo</cite> into the field. Rather than type the rest of
the name of the topping now hit &lt;control&gt;&lt;space&gt; (hold down the control
key and hit the space bar). Protégé should auto-complete the name for
you and the field should now contain: <cite>hasTopping some MozzarellaTopping</cite>.
This is a useful technique for any part of the Protégé UI. Whenever you
enter the name of some entity you can do
&lt;control&gt;&lt;space&gt;. If there is only one possible completion for the
string then Protégé will fill in the appropriate name. If there are
multiple possible completions Protégé will create a menu with all the
possible completions and allow you to select the one you want.</p></li>
<li><p>Click on <cite>OK</cite> to enter the new restriction.</p></li>
<li><p>Repeat steps 1-5 only this time add the restriction <cite>hasTopping some TomatoTopping</cite>.
Remember to use &lt;control&gt;&lt;space&gt; to save time typing.
Synchronize the reasoner to make sure things are consistent. Your UI
should now look similar to figure 4.18.</p></li>
</ol>
<hr class="docutils" />
<figure class="align-center align-default" id="id25">
<img alt="_images/18.png" class="no-scaled-link" src="_images/18.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 4.18 Definition for the class MargheritaPizza</em></span><a class="headerlink" href="#id25" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id25" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Note in figure 4.18 the two classes listed under <cite>Disjoint With</cite> and
highlighted in yellow. This is an example of an inference from the
reasoner. When we defined <code class="docutils literal notranslate"><span class="pre">Pizza</span></code>, <code class="docutils literal notranslate"><span class="pre">PizzaBase</span></code>, and <code class="docutils literal notranslate"><span class="pre">PizzaTopping</span></code> we made
those 3 classes disjoint. I.e., no individual can be a member of more
than one of those classes.
| Since <code class="docutils literal notranslate"><span class="pre">MargheritaPizza</span></code> is a subclass of <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> it is also disjoint with
<code class="docutils literal notranslate"><span class="pre">PizzaBase</span></code> and
<code class="docutils literal notranslate"><span class="pre">PizzaTopping</span></code>, so the reasoner has added this information to the
definition of <code class="docutils literal notranslate"><span class="pre">MargheritaPizza</span></code> and as with all inferences from the
reasoner highlighted the new information in yellow.</p>
<p>We will now create the class to represent an <code class="docutils literal notranslate"><span class="pre">AmericanaPizza</span></code>, which has
toppings of pepperoni, mozzarella and tomato. Because the class
<code class="docutils literal notranslate"><span class="pre">AmericanaPizza</span></code> is similar to the class <code class="docutils literal notranslate"><span class="pre">MargheritaPizza</span></code> (i.e., an
<code class="docutils literal notranslate"><span class="pre">AmericanaPizza</span></code> is almost the same as a <code class="docutils literal notranslate"><span class="pre">MargheritaPizza</span></code> but with an extra
topping of pepperoni) we will make a clone of the <code class="docutils literal notranslate"><span class="pre">MargheritaPizza</span></code> class
and then add an extra restriction to say that it has a topping of
pepperoni.</p>
<p><strong>Exercise 16: Create AmericanaPizza by Cloning MargheritaPizza and Adding Additional Restrictions</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Select <cite>MargheritaPizza</cite> from the class hierarchy on the <cite>Classes</cite> tab.</p></li>
<li><p>Select <cite>Edit&gt;Duplicate selected class</cite>. This will bring up a dialogue
for you to duplicate the class. The default is the name of the existing
class so there will be a red error message when you start because you
need to enter a new name. Change the name from <cite>MargheritaPizza</cite> to
<cite>AmericanaPizza</cite>. Leave all the other options as they are and then select
<cite>OK</cite>.</p></li>
<li><p>Make sure that <cite>AmericanaPizza</cite> is still selected. Click on the Add
icon <cite>(+)</cite> next to the <cite>SubClass Of</cite> field in the <cite>Description</cite> view for
AmericanaPizza.</p></li>
<li><p>Use either the <cite>Object restriction creator</cite> tab or the <cite>Class expression editor</cite> tab
to add the additional restriction: <cite>hasTopping some PepperoniTopping</cite>.</p></li>
<li><p>Click on <cite>OK</cite> to enter the new restriction.</p></li>
<li><p>Edit the comment annotation on AmericanaPizza. It should currently
be: <cite>A pizza that only has Mozzarella and Tomato toppings</cite> since it was
copied over from MargheritaPizza. Note that at the top right of the
comment there are three little icons, an <cite>&#64;</cite> sign, an <cite>X</cite> and an <cite>O</cite>. Click on
the O. This icon is the one you use to edit any existing data in
Protégé. This should bring up a window where you can edit the comment.
Change it to something appropriate such as: <cite>A pizza that only has Mozzarella, Tomato, and Pepperoni toppings</cite>.
Then click on <cite>OK</cite> to enter the edit to the comment.</p></li>
</ol>
<hr class="docutils" />
<p><strong>Exercise 17: Create AmericanaHotPizza and SohoPizza</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>An AmericanaHotPizza is almost the same as an AmericanaPizza but
has Jalapeno peppers on it. Create this by cloning the class
<cite>AmericanaPizza</cite> and adding an existential restriction along the
<cite>hasTopping</cite> property with a filler of <cite>JalapenoPepperTopping</cite>.</p></li>
<li><p>A SohoPizza is almost the same as a MargheritaPizza but has
additional toppings of olives and parmesan cheese — create this by
cloning <cite>MargheritaPizza</cite> and adding two existential restrictions along
the property <cite>hasTopping</cite>, one with a filler of <cite>OliveTopping</cite>, and one
with a filler of <cite>ParmesanTopping</cite>.</p></li>
</ol>
<hr class="docutils" />
<p><strong>Exercise 18: Make Subclasses of NamedPizza Disjoint</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>We want to make these subclasses of NamedPizza disjoint from each
other. I.e., any individual can belong to at most one of these
classes. To do that first select <cite>MargheritaPizza</cite> (or any other
subclass of NamedPizza).</p></li>
<li><p>Click on the <cite>(+)</cite> sign next to <cite>Disjoint With</cite> near the bottom of the
<cite>Description</cite> view. This will bring up a Class hierarchy view. Use this
to navigate to the subclasses of NamedPizza and use <cite>&lt;control&gt;&lt;leftclick&gt;</cite>
to select all of the other sibling classes to the one you
selected. Then select <cite>OK</cite>. You should now see the appropriate disjoint
axioms showing up on each subclass of NamedPizza. Synchronize the
reasoner. Your UI should look similar to figure 4.19 now.</p></li>
</ol>
<hr class="docutils" />
<figure class="align-center align-default" id="id26">
<img alt="_images/19.png" class="no-scaled-link" src="_images/19.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 4.19 Subclasses of NamedPizza are Disjoint</em></span><a class="headerlink" href="#id26" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id26" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<h3 id="detecting-a-class-that-can-t-have-members"><span class="sectnum">4.10.4. </span>Detecting a Class that can’t Have Members<a class="headerlink" href="#detecting-a-class-that-can-t-have-members" title="Permalink to this heading">¶</a></h3>
<p>Next, we are going to use the reasoner to detect a class with a
definition that means it can never have any members. In the current
version of Protégé when the reasoner detects an inconsistency or
problem on some operating systems the UI can occasionally lock up and
be hard to use. So to make sure you don’t lose any of your work save
your ontology using <cite>File&gt;Save</cite>.</p>
<p>Sometimes it can be useful to create a class that we think should be
impossible to instantiate to make sure the ontology is modeled as we
think it is. Such a class is called a Probe Class.</p>
<p><strong>Exercise 19: Add a Probe Class called ProbeInconsistentTopping</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Select the class <cite>CheeseTopping</cite> from the class hierarchy.</p></li>
<li><p>Create a subclass of <cite>CheeseTopping</cite> called <cite>ProbeInconsistentTopping</cite>.</p></li>
<li><p>Click on the Add icon <cite>(+)</cite> next to the <cite>SubClass Of</cite> field in the
<cite>Description</cite> view for <code class="docutils literal notranslate"><span class="pre">ProbeInconsistentTopping</span></code>.</p></li>
<li><p>Select the <cite>Class hierarchy tab</cite> from the dialogue that pops up. This
will bring up a small view that looks like the class hierarchy tab you
have been using to add new classes. Use this to navigate to and select
the class <cite>VegetableTopping</cite>. Click on <cite>OK</cite>.</p></li>
<li><p>Make sure to save your current ontology file. Now run the reasoner.
You should see that <code class="docutils literal notranslate"><span class="pre">ProbeInconsistentTopping</span></code> is now highlighted in red
indicating it is inconsistent.</p></li>
<li><p>Click on <cite>ProbeInconsistentTopping</cite> to see why it is highlighted in
red. Notice that at the top of the Description view you should now see
<cite>owl:Nothing</cite> under the <cite>Equivalent To</cite> field. This means that the probe
class is equivalent to <code class="docutils literal notranslate"><span class="pre">owl:Nothing</span></code>. The <code class="docutils literal notranslate"><span class="pre">owl:Nothing</span></code> class is the
opposite of <code class="docutils literal notranslate"><span class="pre">owl:Thing</span></code>. Whereas all individuals are instances of <code class="docutils literal notranslate"><span class="pre">owl:Thing</span></code>, no individual can
ever be an instance of <code class="docutils literal notranslate"><span class="pre">owl:Nothing</span></code>. The <code class="docutils literal notranslate"><span class="pre">owl:Nothing</span></code> class is equivalent
to the empty set in set theory.</p></li>
<li><p>There should be a <cite>?</cite> icon just to the right of <cite>owl:Nothing</cite>. As with
any inference of the reasoner it is possible to click on the new
information and generate an explanation for it. Do that now, click on
the <cite>?</cite> icon. This should generate a new window that looks like figure 4.20.
The explanation is that <code class="docutils literal notranslate"><span class="pre">ProbeInconsistentTopping</span></code> is a subclass of <code class="docutils literal notranslate"><span class="pre">CheeseTopping</span></code> and
<code class="docutils literal notranslate"><span class="pre">VegetableTopping</span></code> but those two classes are disjoint.</p></li>
<li><p>Click <cite>OK</cite> to dismiss the window. Delete the class
ProbeInconsistentTopping by selecting it and then clicking on the delete
class icon at the top of the classes view (see figure 4.4).</p></li>
<li><p>Synchronize the reasoner.</p></li>
</ol>
<hr class="docutils" />
<figure class="align-center align-default" id="id27">
<img alt="_images/20.png" class="no-scaled-link" src="_images/20.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 4.20 Explanation for why ProbeInconsistentTopping is equivalent to owl:Nothing</em></span><a class="headerlink" href="#id27" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id27" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<h2 id="primitive-and-defined-classes-necessary-and-sufficient-axioms"><span class="sectnum">4.11. </span>Primitive and Defined Classes (Necessary and Sufficient Axioms)<a class="headerlink" href="#primitive-and-defined-classes-necessary-and-sufficient-axioms" title="Permalink to this heading">¶</a></h2>
<p>All of the classes that we have created so far have only used
necessary axioms to describe them. Necessary axioms can be read as,
<em>If something is a member of this class then it is necessary to fulfil
these conditions</em>. With necessary axioms alone, we <em>cannot</em> say that:
<em>If something fulfils these conditions then it must be a member of
this class</em>.</p>
<p>Let’s illustrate this with an example. We will create a subclass of
<code class="docutils literal notranslate"><span class="pre">Pizza</span></code> called <code class="docutils literal notranslate"><span class="pre">CheesyPizza</span></code>, which will be a <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> that has at least one
kind of <code class="docutils literal notranslate"><span class="pre">CheeseTopping</span></code>.</p>
<p><strong>Exercise 20: Create the CheesyPizza class</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Select <cite>Pizza</cite> in the class hierarchy on the Classes tab.</p></li>
<li><p>Select the Add Subclass icon (see figure 4.4). Name the new subclass <cite>CheesyPizza</cite>.</p></li>
<li><p>Make sure CheesyPizza is selected. Click on the Add icon <cite>(+)</cite> next to
the <cite>SubClass Of</cite> field in the <cite>Description</cite> view.</p></li>
<li><p>Select the Class expression editor tab. Type in the new axiom:
<cite>hasTopping some CheeseTopping</cite>. Remember you can use <cite>&lt;control&gt;&lt;space&gt;</cite>
to auto-complete each word in the axiom, e.g., type <cite>hasT</cite> and then
<cite>&lt;control&gt;&lt;space&gt;</cite> to auto-complete the rest. If you haven’t typed
enough for Protégé to
unambiguously choose one entity or Description Logic keyword you will
be prompted with a menu of possible completions. Click <cite>OK</cite> to enter the
new restriction axiom.</p></li>
</ol>
<hr class="docutils" />
<div class="pitfall admonition">
<p class="admonition-title">Warning</p>
<p>Note that if you just type a few characters, the number of
possible completions may be large resulting in an unwieldy menu.
Also, Protégé doesn’t do things like type checking on possible
completions. For example, if you type “Chee” and do
&lt;control&gt;&lt;space&gt; you will be prompted with <code class="docutils literal notranslate"><span class="pre">CheeseTopping</span></code> and
<code class="docutils literal notranslate"><span class="pre">CheesyPizza</span></code> as possible completions even though a <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> is not in
the range of <code class="docutils literal notranslate"><span class="pre">hasTopping</span></code>. This is where the reasoner can also
help. If you enter a class that is not in the range of <code class="docutils literal notranslate"><span class="pre">hasTopping</span></code>
the reasoner will signal an inconsistency.</p>
</div>
<p>Our current description of <code class="docutils literal notranslate"><span class="pre">CheesyPizza</span></code> says that if something is a
<code class="docutils literal notranslate"><span class="pre">CheesyPizza</span></code> it is <em>necessarily</em> a <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> and it is <em>necessary</em> for it
to have at least one topping that is a kind of <code class="docutils literal notranslate"><span class="pre">CheeseTopping</span></code>. Now
consider some random individual. Suppose that we know that this
individual is a member of the class <code class="docutils literal notranslate"><span class="pre">Pizza</span></code>. We also know that this
individual has at least one kind of <code class="docutils literal notranslate"><span class="pre">CheeseTopping</span></code>. However, given our
current description of <code class="docutils literal notranslate"><span class="pre">CheesyPizza</span></code> this knowledge is not sufficient
to determine that the individual is a member of the class
<code class="docutils literal notranslate"><span class="pre">CheesyPizza</span></code>. To make this possible we need to change the conditions
for <code class="docutils literal notranslate"><span class="pre">CheesyPizza</span></code> from <em>necessary</em> conditions to <em>necessary AND
sufficient</em> conditions. This means that not only are the conditions
<em>necessary</em> for membership of the class <code class="docutils literal notranslate"><span class="pre">CheesyPizza</span></code>, they are also
<em>sufficient</em> to determine that any random individual that satisfies
them must be a member of the class <code class="docutils literal notranslate"><span class="pre">CheesyPizza</span></code>.</p>
<p>A class (such as all the classes we have defined so far) that only
has necessary conditions is called a <em>primitive class</em>. A class that
has necessary and sufficient conditions is known as a <em>defined
class</em>. In order to convert necessary conditions to necessary and
sufficient conditions, the conditions must be moved from under the
<cite>SubClass Of</cite> header in the class description view to be under the
<cite>Equivalent To</cite> header. This can be done with the menu option:
<cite>Edit&gt;Convert to defined class</cite>.</p>
<p><strong>Exercise 21: Convert CheesyPizza from a Primitive Class to a Defined Class</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Make sure <cite>CheesyPizza</cite> is selected.</p></li>
<li><p>Select the menu option: <cite>Edit&gt;Convert to defined class</cite>.</p></li>
<li><p>Synchronize the reasoner.</p></li>
</ol>
<hr class="docutils" />
<p>Your screen should now look similar to figure 4.21. Note that when a
class is a defined class it is shown in the UI with three horizontal
stripes in the circle next to its name.</p>
<p>So far we have seen the reasoner do simple things such as propagate
disjoint axioms from super classes down to subclasses. However, the
reasoner is capable of doing much more. Now that we have a defined
class we can see an example of this. Notice that there are two tabs
in the <cite>Class hierarchy</cite> view. The one shown in figure 4.21 is the
asserted hierarchy. This is the hierarchy as defined by user declared
axioms.</p>
<p>The other tab is the <cite>Class hierarchy (inferred)</cite> tab. This is the
hierarchy as inferred by the reasoner. Up until we created a defined
class the two tabs would be identical because we had only primitive
classes in the ontology. Now that we have a defined class the
inferred hierarchy will look different. Select the <cite>Class hierarchy
(inferred)</cite> tab. Make sure that the reasoner is synchronized (it
should say <cite>Reasoner active</cite> as in figure 4.21). Also, make sure to
expand the <code class="docutils literal notranslate"><span class="pre">CheesyPizza</span></code> class in this tab. You should see a screen
similar to figure 4.22. As you should see in the inferred tab the
reasoner has inferred that all the <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> classes with a cheese
topping are subclasses of <code class="docutils literal notranslate"><span class="pre">CheesyPizza</span></code>.</p>
<figure class="align-center align-default" id="id28">
<img alt="_images/211.png" class="no-scaled-link" src="_images/211.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<strong>Figure 4.21 CheesyPizza as a Defined Class</strong></span><a class="headerlink" href="#id28" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id28" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center align-default" id="id29">
<img alt="_images/22.png" class="no-scaled-link" src="_images/22.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<strong>Figure 4.22 Classes Inferred by the Reasoner to be subclasses of CheesyPizza</strong></span><a class="headerlink" href="#id29" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id29" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<h2 id="universal-restrictions"><span class="sectnum">4.12. </span>Universal Restrictions<a class="headerlink" href="#universal-restrictions" title="Permalink to this heading">¶</a></h2>
<p>All of the restrictions we have created so far have been existential
restrictions (defined using the <code class="docutils literal notranslate"><span class="pre">some</span></code> DL keyword). Existential
restrictions specify the existence of at least one relationship along
a given property to an individual that is a member of a specific class
(specified by the filler). However, existential restrictions do not
mandate that the only relationships for the given property that can
exist must be to individuals that are members of the specified filler
class.</p>
<p>For example, we could use an existential restriction <code class="docutils literal notranslate"><span class="pre">hasTopping</span> <span class="pre">some</span> <span class="pre">MozzarellaTopping</span></code>
to describe the individuals that have at least one
relationship along the property <code class="docutils literal notranslate"><span class="pre">hasTopping</span></code> to an individual that is a
member of the class <code class="docutils literal notranslate"><span class="pre">MozzarellaTopping</span></code>. This restriction does not imply
that all of the <code class="docutils literal notranslate"><span class="pre">hasTopping</span></code> relationships must be to a member of the
class <code class="docutils literal notranslate"><span class="pre">MozzarellaTopping</span></code>. To restrict the relationships for a given
property to individuals that are members of a specific class we must
use a universal restriction. Universal restrictions correspond to the
symbol <code class="docutils literal notranslate"><span class="pre">∀</span></code> in First Order Logic. They constrain the relationships along
a given property to individuals that are members of a specific class.
For example, the universal restriction <code class="docutils literal notranslate"><span class="pre">∀</span> <span class="pre">hasTopping</span> <span class="pre">VegetableTopping</span></code>
describes the individuals all of whose <code class="docutils literal notranslate"><span class="pre">hasTopping</span></code> relationships are to
members of the class <code class="docutils literal notranslate"><span class="pre">VegetableTopping</span></code> — the individuals do not have a
<code class="docutils literal notranslate"><span class="pre">hasTopping</span></code> relationship to individuals that aren’t members of the
class <code class="docutils literal notranslate"><span class="pre">VegetableTopping</span></code>.</p>
<p>Suppose we want to create a class called <code class="docutils literal notranslate"><span class="pre">VegetarianPizza</span></code>. Individuals
that are members of this class can only have toppings that are a
<code class="docutils literal notranslate"><span class="pre">CheeseTopping</span></code> or <code class="docutils literal notranslate"><span class="pre">VegetableTopping</span></code>. To do this we can use a universal
restriction:</p>
<p><strong>Exercise 22: Create a Defined Class called VegetarianPizza</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Select the <cite>Pizza</cite> in the <cite>Classes</cite> tab. Create a subclass of <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> and
name it <code class="docutils literal notranslate"><span class="pre">VegetarianPizza</span></code>.</p></li>
<li><p>Make sure <cite>VegetarianPizza</cite> is selected. Click
on the Add icon <cite>(+)</cite> next to the <cite>SubClass Of</cite> field in the <cite>Description</cite>
view.</p></li>
<li><p>Select the <cite>Class expression editor</cite> tab from the pop-up window. Type
in the Description Logic axiom:
<cite>hasTopping only (VegetableTopping or CheeseTopping).</cite> Click on <cite>OK</cite>.</p></li>
<li><p>Make sure <cite>VegetarianPizza</cite> is still selected.
Run the <cite>Edit&gt;Convert to defined class</cite> command.</p></li>
<li><p><cite>VegetarianPizza</cite> should now have three horizontal lines through it
just as <cite>CheesyPizza</cite> does.
Also, the <cite>Equivalent To</cite> field in the Description view should have:
<cite>Pizza and (hasTopping only (CheeseTopping or VegetableTopping))</cite>.
Note that another way to create defined classes is to enter the Description Logic
axiom directly into the <cite>Equivalent To</cite> field.</p></li>
<li><p>Synchronize the reasoner.</p></li>
</ol>
<hr class="docutils" />
<div class="explain admonition">
<p class="admonition-title">Explanation</p>
<p>This means that if something is a member of the class
<code class="docutils literal notranslate"><span class="pre">VegetarianPizza</span></code> it is necessary for it to be a kind of <code class="docutils literal notranslate"><span class="pre">Pizza</span></code>
and it is necessary for it to only (<code class="docutils literal notranslate"><span class="pre">∀</span></code> universal quantifier)
have toppings that are kinds of <code class="docutils literal notranslate"><span class="pre">CheeseTopping</span></code> or kinds of
<code class="docutils literal notranslate"><span class="pre">VegetableTopping</span></code>. In other words, all
<code class="docutils literal notranslate"><span class="pre">hasTopping</span></code> relationships that individuals which are members of
the class <code class="docutils literal notranslate"><span class="pre">VegetarianPizza</span></code> participate in must be to individuals
that are either members of the class <code class="docutils literal notranslate"><span class="pre">CheeseTopping</span></code> or
<code class="docutils literal notranslate"><span class="pre">VegetableTopping</span></code>. The class <code class="docutils literal notranslate"><span class="pre">VegetarianPizza</span></code> also contains
individuals that are <code class="docutils literal notranslate"><span class="pre">Pizzas</span></code> and do not participate in any
<code class="docutils literal notranslate"><span class="pre">hasTopping</span></code> relationships.</p>
</div>
<div class="pitfall admonition">
<p class="admonition-title">Warning</p>
<p>In situations like the above example, a common mistake is to use
an intersection instead of a union. For example,
<code class="docutils literal notranslate"><span class="pre">CheeseTopping</span></code> <em>and</em> <code class="docutils literal notranslate"><span class="pre">VegetableTopping</span></code>. Although <code class="docutils literal notranslate"><span class="pre">CheeseTopping</span></code>
and <code class="docutils literal notranslate"><span class="pre">Vegetable</span></code> might be a natural thing to say in English, this
logically means something that is simultaneously a kind of
<code class="docutils literal notranslate"><span class="pre">CheeseTopping</span></code> and <code class="docutils literal notranslate"><span class="pre">VegetableTopping</span></code>. This is incorrect because we
have stated that <code class="docutils literal notranslate"><span class="pre">CheeseTopping</span></code> and <code class="docutils literal notranslate"><span class="pre">VegetableTopping</span></code> are disjoint
classes and hence no individual can be an instance of both. If we
used such a definition the reasoner would detect the
inconsistency.</p>
</div>
<div class="pitfall admonition">
<p class="admonition-title">Warning</p>
<p>In the above example it might have been tempting to create two
universal restrictions — one for <code class="docutils literal notranslate"><span class="pre">CheeseTopping</span></code>
(<code class="docutils literal notranslate"><span class="pre">∀</span> <span class="pre">hasTopping</span> <span class="pre">CheeseTopping</span></code>) and one for
<code class="docutils literal notranslate"><span class="pre">VegetableTopping</span></code> (<code class="docutils literal notranslate"><span class="pre">∀</span> <span class="pre">hasTopping</span> <span class="pre">VegetableTopping</span></code>). However, when
multiple restrictions are used (for any type of restriction)
the total description is taken to be the intersection of the
individual restrictions. This would have therefore been
equivalent to one restriction with a filler that is the
intersection of <code class="docutils literal notranslate"><span class="pre">MozzarellaTopping</span></code> <em>and</em> <code class="docutils literal notranslate"><span class="pre">TomatoTopping</span></code>— as
explained above this would have been logically incorrect.</p>
</div>
<h2 id="automated-classification-and-open-world-reasoning"><span class="sectnum">4.13. </span>Automated Classification and Open World Reasoning<a class="headerlink" href="#automated-classification-and-open-world-reasoning" title="Permalink to this heading">¶</a></h2>
<p>Make sure that the reasoner is synchronized (the little text in the
lower right corner should say <cite>Reasoner active</cite>). Now switch from the
<cite>Class hierarchy</cite> tab to the <cite>Class hierarchy (inferred)`tab. You may
notice something that seems perplexing. The classes ``MargheritaPizza`</cite>
and <code class="docutils literal notranslate"><span class="pre">SohoPizza</span></code> both only have vegetable and cheese toppings. So one
might expect that the reasoner would classify them as subclasses of
<code class="docutils literal notranslate"><span class="pre">VegetarianPizza</span></code> as it recently (in <a class="reference external" href="#primitive-and-defined-classes-necessary-and-sufficient-axioms">section 4.11</a>) classified them
and others as subclasses of <code class="docutils literal notranslate"><span class="pre">CheesyPizza</span></code>. The reason this didn’t
happen is something called the Open World Assumption (OWA).
This is one of the concepts of OWL that can be most confusing for new
and even experienced users because it is different than the Close
World Assumption (CWA) used in most other programming and knowledge
representation languages.</p>
<p>In most languages using the CWA we assume that everything that is
currently known about the system is already in the database.
However, OWL was meant to be a language to bring semantics to the
Internet so the language designers chose the OWA. The open world
assumption means that we cannot assume something doesn’t exist just
because it isn’t currently in the ontology. The Internet is an open
system. The information could be out there in some data source that
hasn’t yet been integrated into our ontology. Thus, we can’t
conclude some information doesn’t exist unless it is <em>explicitly
stated that it does not exist</em>. In other words, because something
hasn’t been stated to be true, it cannot be assumed to be false —
it is assumed that the knowledge just hasn’t been added to the
knowledge base. In the case of our pizza ontology, we have stated
that <code class="docutils literal notranslate"><span class="pre">MargheritaPizza</span></code> has toppings that are kinds of
<code class="docutils literal notranslate"><span class="pre">MozzarellaTopping</span></code> and also kinds of <code class="docutils literal notranslate"><span class="pre">TomatoTopping</span></code>. Because of the
open world assumption, until we explicitly say that a
<code class="docutils literal notranslate"><span class="pre">MargheritaPizza</span></code> only has these kinds of toppings, it is assumed by
the reasoner that a
<code class="docutils literal notranslate"><span class="pre">MargheritaPizza</span></code> could have other toppings. To specify explicitly
that a <code class="docutils literal notranslate"><span class="pre">MargheritaPizza</span></code> has toppings that are kinds of
<code class="docutils literal notranslate"><span class="pre">MozzarellaTopping</span></code> or kinds of <code class="docutils literal notranslate"><span class="pre">TomatoTopping</span></code> and only kinds of
<code class="docutils literal notranslate"><span class="pre">MozzarellaTopping</span></code> or <code class="docutils literal notranslate"><span class="pre">TomatoTopping</span></code>, we must add what is known as a
closure axiom on the <code class="docutils literal notranslate"><span class="pre">hasTopping</span></code> property.</p>
<p>A closure axiom on a property consists of a universal restriction that
says that a property can only be filled by specified fillers. The
restriction has a filler that is the union of the fillers that occur
in the existential restrictions for the property. For example, the
closure axiom on the <code class="docutils literal notranslate"><span class="pre">hasTopping</span></code> property for <code class="docutils literal notranslate"><span class="pre">MargheritaPizza</span></code> is a
universal restriction that acts along the <code class="docutils literal notranslate"><span class="pre">hasTopping</span></code> property, with a
filler that is the union of <code class="docutils literal notranslate"><span class="pre">MozzarellaTopping</span></code> and also <code class="docutils literal notranslate"><span class="pre">TomatoTopping</span></code>.
i.e. <code class="docutils literal notranslate"><span class="pre">hasTopping</span></code> only (<code class="docutils literal notranslate"><span class="pre">MozzarellaTopping</span></code> or <code class="docutils literal notranslate"><span class="pre">TomatoTopping</span></code>).</p>
<p><strong>Exercise 23: Add a Closure Axiom on the hasTopping Property for MargheritaPizza</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Make sure that <code class="docutils literal notranslate"><span class="pre">MargheritaPizza</span></code> is selected in the class hierarchy in
the <cite>Classes</cite> tab.</p></li>
<li><p>Click on the Add icon <cite>(+)</cite> next to the <cite>SubClass Of</cite> field in the
<cite>Description</cite> view.</p></li>
<li><p>Select the <cite>Class expression editor</cite> tab from the pop-up window. Type
in the Description Logic axiom:
<cite>hasTopping only (MozzarellaTopping or TomatoTopping)</cite>.</p></li>
<li><p>Click on <cite>OK</cite>.</p></li>
<li><p>Repeat steps 1-4 but this time click on <cite>SohoPizza</cite> and use the axiom:
<cite>hasTopping only (MozzarellaTopping or TomatoTopping or ParmesanTopping or OliveTopping)</cite>.</p></li>
<li><p>Synchronize the reasoner.</p></li>
</ol>
<hr class="docutils" />
<p>The previous axioms said that for example that it was necessary for
any <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> that was a
<code class="docutils literal notranslate"><span class="pre">MargheritaPizza</span></code> to have a <code class="docutils literal notranslate"><span class="pre">MozzarellaTopping</span></code> and a <code class="docutils literal notranslate"><span class="pre">TomatoTopping</span></code>. The
new axioms say that a <code class="docutils literal notranslate"><span class="pre">MargheritaPizza</span></code> can <em>only</em> have these toppings
and similarly for <code class="docutils literal notranslate"><span class="pre">SohoPizza</span></code> and its toppings. This should supply the
needed information for the reasoner to now make them both subclasses
of
<code class="docutils literal notranslate"><span class="pre">VegetarianPizza</span></code>. Go to the <cite>Class hierarchy (inferred)</cite> tab. You should
now see that
<code class="docutils literal notranslate"><span class="pre">MargheritaPizza</span></code> and <code class="docutils literal notranslate"><span class="pre">SohoPizza</span></code> are both classified as subclasses of
<code class="docutils literal notranslate"><span class="pre">VegetarianPizza</span></code>. Your UI should now look similar to figure 4.23. Note
the various axioms highlighted in yellow. Those are all additional
inferences supplied by the reasoner. For experience you might want to
click on some of the <cite>?</cite>
icons next to these inferences to see the explanations generated by the
reasoner. As you develop more complex ontologies this is a powerful tool
to debug and design your ontology.</p>
<figure class="align-center align-default" id="id30">
<img alt="_images/23.png" class="no-scaled-link" src="_images/23.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 4.23 The Reasoner Inferred that Margherita and Soho Pizzas are subclasses of VegetarianPizza</em></span><a class="headerlink" href="#id30" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id30" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<h2 id="defining-an-enumerated-class"><span class="sectnum">4.14. </span>Defining an Enumerated Class<a class="headerlink" href="#defining-an-enumerated-class" title="Permalink to this heading">¶</a></h2>
<p>A powerful tool in the object-oriented programming (OOP) community is
the concept of design patterns. The idea of a design pattern is to
capture a reusable model that is at a higher level of abstraction than
a specific code library. One of the first and most common design
patterns was the Model-View-Controller pattern first used in Smalltalk
and now almost the default standard for good user interface design.
Since there are significant differences between OWL and standard OOP
the many excellent books on OOP design patterns don’t directly
translate into OWL design patterns. Also, since the use of OWL is more
recent than OOP there does not yet exist the excellent documentation
of OWL patterns that the OOP community has. However, there are already
many design patterns that have been documented for OWL and that can
provide users with ways to save time and to standardize their designs
according to best practices.</p>
<p>One of the most common OWL design patterns is an enumerated class. When
a property has only a few possible values it can be useful to create a
class to represent those values and to explicitly define the class by
listing each possible value. We will show an example of such an
enumerated class by creating a new
property called <code class="docutils literal notranslate"><span class="pre">hasSpiciness</span></code> with only a few possible values ranging
from <code class="docutils literal notranslate"><span class="pre">Mild</span></code> to <code class="docutils literal notranslate"><span class="pre">Hot</span></code>. In this section we will also create the first
individuals in our ontology.</p>
<p><strong>Exercise 24: Create an Enumerated Class to Represent the Spiciness of a Pizza</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Create a new subclass of <code class="docutils literal notranslate"><span class="pre">owl:Thing</span></code> called <code class="docutils literal notranslate"><span class="pre">Spiciness</span></code>.</p></li>
<li><p>Make sure that <cite>Spiciness</cite> is selected. Click on the Add icon <cite>(+)</cite> next
to the <cite>Instances</cite> field in the <cite>Description</cite> view.</p></li>
<li><p>You will be prompted with a window that looks like figure 4.24. The
diamond icon at the top is for creating a new individual. The circle
with an <cite>X</cite> through it is for deleting an individual. Use the diamond icon
to create 3 individuals: <cite>Hot</cite>, <cite>Medium</cite>, and <cite>Mild</cite>, so your UI looks like
figure 4.24, then click on <cite>OK</cite>.</p></li>
<li><p>You may notice that only one of the new individuals was actually
created as an instance of <code class="docutils literal notranslate"><span class="pre">Spiciness</span></code>. That’s okay. The next step will
supply the reasoner with enough information to make the other two also
be instances of <code class="docutils literal notranslate"><span class="pre">Spiciness</span></code>.</p></li>
<li><p>Make sure that <cite>Spiciness</cite> is still selected. Click on the Add icon <cite>(+)</cite>
next to the <cite>Equivalent To</cite> field in the <cite>Description</cite> view. This time we
will create a defined class by directly entering the definition for the
class into this field. Select the Class expression editor tab and enter
the DL axiom: <cite>{Hot, Medium, Mild}</cite>. Select <cite>OK</cite>.</p></li>
<li><p>Now run the reasoner. You should see that Spiciness is now a defined
class and all three individuals: <code class="docutils literal notranslate"><span class="pre">Hot</span></code>, <code class="docutils literal notranslate"><span class="pre">Medium</span></code>, and <code class="docutils literal notranslate"><span class="pre">Mild</span></code>, are now
instances of that class.</p></li>
</ol>
<hr class="docutils" />
<figure class="align-center align-default" id="id31">
<img alt="_images/24.png" class="no-scaled-link" src="_images/24.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 4.24 Creating Individuals for an Enumerated Class</em></span><a class="headerlink" href="#id31" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id31" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<h2 id="adding-spiciness-as-a-property"><span class="sectnum">4.15. </span>Adding Spiciness as a Property<a class="headerlink" href="#adding-spiciness-as-a-property" title="Permalink to this heading">¶</a></h2>
<p>Next we need to add a property that will define the spiciness of a <code class="docutils literal notranslate"><span class="pre">PizzaTopping</span></code>.</p>
<p><strong>Exercise 25: Create and Use the hasSpiciness Property</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Go to the <cite>Object properties</cite> tab. Create a new property called
<cite>hasSpiciness</cite>. Define its domain to be <cite>PizzaTopping</cite> and its range to be
<cite>Spiciness</cite>. Run the reasoner so that it knows about the new property.</p></li>
<li><p>Go back to the Classes tab and select the class
<cite>JalapenoPepperTopping</cite>. Click on the Add icon <cite>(+)</cite> next to the <cite>SubClass Of</cite>
field. Enter the DL axiom: <cite>hasSpiciness value Hot</cite>. Remember you can use
&lt;control&gt;&lt;space&gt; to auto-complete. Click on <cite>OK</cite>.</p></li>
<li><p>Note that this is a different kind of restriction than before. Before
we were defining abstract restrictions such as some. I.e., some value
from a class but the specific individual was not specified, as long as
it was an individual from that class the restriction was satisfied. Now
we are defining a restriction that relates to a specific individual,
hence we use the value keyword rather than the some or only keywords.</p></li>
<li><p>Now we will use this property to define a new class of <code class="docutils literal notranslate"><span class="pre">Pizza</span></code>. Start
by creating a new subclass of <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> called <cite>SpicyPizza</cite>.</p></li>
<li><p>Make sure that <cite>SpicyPizza</cite> is selected. Click on the Add icon <cite>(+)</cite> next
to the <cite>SubClass Of</cite> field. Enter the DL axiom:
<cite>hasTopping some (hasSpiciness value Hot)</cite>.
This says that a <code class="docutils literal notranslate"><span class="pre">SpicyPizza</span></code> must have a
topping that <code class="docutils literal notranslate"><span class="pre">hasSpiciness</span></code> value of <code class="docutils literal notranslate"><span class="pre">Hot</span></code>.</p></li>
<li><p>Convert <cite>SpicyPizza</cite> to a defined class by selecting it and using
<cite>Edit&gt;Convert to defined class</cite>. Run the reasoner.</p></li>
</ol>
<hr class="docutils" />
<p>Now go to the <cite>Class hierarchy (inferred)</cite> tab in the <cite>Classes</cite> tab (see
figure 4.25). You should see that <code class="docutils literal notranslate"><span class="pre">AmericanHotPizza</span></code> is now classified as
a subclass of <code class="docutils literal notranslate"><span class="pre">SpicyPizza</span></code> because it has a topping
(<code class="docutils literal notranslate"><span class="pre">JalapenoPepperTopping</span></code>) that has a spiciness value of <code class="docutils literal notranslate"><span class="pre">Hot</span></code>.</p>
<h2 id="cardinality-restrictions"><span class="sectnum">4.16. </span>Cardinality Restrictions<a class="headerlink" href="#cardinality-restrictions" title="Permalink to this heading">¶</a></h2>
<p>In OWL we can describe the class of individuals that have at least, at
most, or exactly a specified number of relationships with other
individuals or datatype values. The restrictions that describe these
classes are known as Cardinality Restrictions. For a given property P,
a Minimum Cardinality Restriction specifies the minimum number of P
relationships that an individual must participate in. A Maximum
Cardinality Restriction specifies the maximum number of P
relationships that an individual can participate in. A Cardinality
Restriction specifies the exact number of P relationships that an
individual must participate in. Relationships (for example between two
individuals) are only counted as separate relationships if it can be
determined that the individuals that are the fillers for the
relationships are different from each other.</p>
<p>Let’s add a cardinality restriction to our Pizza Ontology. We will
create a new subclass of <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> called <code class="docutils literal notranslate"><span class="pre">InterestingPizza</span></code> which will be
defined to have 3 or more toppings.</p>
<figure class="align-center align-default" id="id32">
<img alt="_images/25.png" class="no-scaled-link" src="_images/25.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 4.25 AmericanHotPizza classified as SpicyPizza</em></span><a class="headerlink" href="#id32" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id32" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p><strong>Exercise 26: Create an InterestingPizza that has at least three toppings</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Create a subclass of <cite>Pizza</cite> called <cite>InterestingPizza</cite>.</p></li>
<li><p>Click on the Add icon <cite>(+)</cite> next to the <cite>SubClass Of</cite> field. Use the
<cite>Class expression editor</cite> tab and enter <cite>hasTopping min 3 PizzaTopping</cite> and
click on <cite>OK</cite>.</p></li>
<li><p>Make sure <cite>InterestingPizza</cite> is still selected and use the
<cite>Edit&gt;Convert to defined class</cite> option to turn <code class="docutils literal notranslate"><span class="pre">InterestingPizza</span></code>
into a defined class.</p></li>
<li><p>Run the reasoner.</p></li>
</ol>
<hr class="docutils" />
<p>Go to the <cite>Class hierarchy (inferred)</cite> tab in the <cite>Classes</cite> tab and click on
<cite>InterestingPizza</cite>. You should see that there are three <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> classes that
are classified as interesting: <cite>AmericanaHotPizza</cite>, <cite>AmericanaPizza</cite>, and
<cite>SohoPizza</cite>.</p>
<h1 id="datatype-properties"><span id="chap5"></span><span class="sectnum">5. </span>Datatype Properties<a class="headerlink" href="#datatype-properties" title="Permalink to this heading">¶</a></h1>
<p>So far we have been describing object properties. These are properties
that have a range that is some class. As with most other object-oriented
languages OWL also has the capability to define properties with the
range of a simple datatype such as a string or integer. Object purists
will argue that everything should be an object. However, to borrow a
quote from The Amazing Spiderman: “with great power comes great
overhead”. I.e., the extra capabilities that one has with a class and an
instance also means that instances take up more space and can be slower
to process than simple datatypes. For that reason, OWL comes with a
large library of pre-existing datatypes that are mostly imported from
XML. That is why many of the predefined datatypes in Protégé have a
prefix of <em>xsd</em> for example <code class="docutils literal notranslate"><span class="pre">xsd:string</span> <span class="pre">and</span> <span class="pre">xsd:integer</span></code>. It is also
possible to create new basic datatypes. However, for the majority of use
cases, if one needs a datatype that doesn’t map to one of the predefined
types the best solution is to usually just define a class.</p>
<p>A property with a range that is a simple datatype is known as a datatype
property. This is analogous to the distinction between an association
and an attribute in the Unified Modeling Language (UML) OOP modeling
language. A UML association is similar to an OWL object property and a
UML attribute is similar to an OWL datatype property. It is also
analogous to the distinction between relations and attributes in
entity-relation modeling. A relation in an E/R model is similar to an
object property in OWL and an attribute is similar to a datatype
property. Because datatypes don’t have all the power of OWL objects,
many of the capabilities for object properties described in
<a class="reference external" href="#owl-object-property-characteristics">section 4.8</a>
such as having an inverse or being transitive aren’t available for
datatype properties.</p>
<h2 id="defining-a-data-property"><span class="sectnum">5.1. </span>Defining a Data Property<a class="headerlink" href="#defining-a-data-property" title="Permalink to this heading">¶</a></h2>
<p>As with other OWL entities, datatype properties can be defined either
via the <cite>Data properties</cite> tab in the <cite>Entities</cite> tab or in the
<cite>Data properties</cite> tab available via the <cite>Window&gt;Tabs&gt;Data properties</cite> option.</p>
<p>We will use datatype properties to describe the calorie content of
pizzas. We will then use some numeric ranges to broadly classify
particular pizzas as high or low calorie. In order to do this we need to
complete the following steps:</p>
<ol class="arabic simple">
<li><p>Create a datatype property <code class="docutils literal notranslate"><span class="pre">hasCaloricContent</span></code>, which will be used to
state the calorie content of particular pizzas.</p></li>
<li><p>Create several example <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> individuals with specific calorie contents.</p></li>
<li><p>Create two classes broadly categorizing pizzas as low or high calorie.</p></li>
</ol>
<p><strong>Exercise 27: Create a Datatype Property called hasCaloricContent</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Open a <cite>Data properties</cite> tab. Select <cite>owl:topDataProperty</cite>.</p></li>
<li><p>Click on the <cite>Add sub property</cite> icon in the upper left corner. This
works just the same as the UI for adding object properties.</p></li>
<li><p>Name the new data property <cite>hasCaloricContent</cite> and select <cite>OK</cite>.</p></li>
<li><p>Click on the <cite>(+)</cite> icon next to <cite>Domains</cite> in the <cite>Description</cite> view for
<cite>hasCaloricContent</cite>. Use the <cite>Class hierarchy tab</cite> to select the <cite>Pizza</cite> class
as the domain.</p></li>
<li><p>Click on the <cite>(+)</cite> icon next to <cite>Ranges</cite> in the Description view for
<cite>hasCaloricContent</cite>. Select the <cite>Built in datatypes</cite> tab from the pop-up
menu. Select <cite>xsd:integer7</cite> from the rather long menu of possible built-in
datatypes. This is the default datatype to use for integer data
properties.</p></li>
<li><p>Click the <cite>Functional</cite> check box next to the <cite>Description</cite> view. A Pizza
can only have one caloric content and hence is functional. Data
properties are often functional.</p></li>
</ol>
<ol class="arabic simple" start="5">
<li><p>Select <cite>OK</cite> and run the reasoner. Your UI should look similar to figure 5.1.</p></li>
</ol>
<hr class="docutils" />
<figure class="align-center align-default" id="id33">
<img alt="_images/110.png" class="no-scaled-link" src="_images/110.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 5.1 hasCaloricContent Data Property</em></span><a class="headerlink" href="#id33" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id33" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Note that as with object properties defining a domain and/or range is
optional. In general, it is a good practice to do so as it can lead to
finding errors in your ontology during the modeling phase rather than at
run time.</p>
<h2 id="customizing-the-protege-user-interface"><span class="sectnum">5.2. </span>Customizing the Protégé User Interface<a class="headerlink" href="#customizing-the-protege-user-interface" title="Permalink to this heading">¶</a></h2>
<p>In order to demonstrate our new data property, we will need to create
some instances of the <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> class and set the value of the data
property <code class="docutils literal notranslate"><span class="pre">hasCaloricContent</span></code>. One of the advantages of Protégé is that
it is highly customizable to your specific requirements and work
style. There are many views that are available that aren’t included in
the default Protégé environment because it would be too cluttered. In
addition, all of the views that you have already used can be resized,
removed, or added to existing tabs. You can also create completely new
tabs of your own.</p>
<p>As an example, we are going to first bring up a new major tab called
<cite>Individuals by class</cite>. This tab can be useful to create individuals and
to add or edit their object and data property values. We are going to
customize this tab to make it easier to use by adding a new view to it.</p>
<p>To begin use the menu option <cite>Window&gt;Tabs&gt;Individuals by class</cite> to bring
up this new tab. Of course, if it already exists in your UI simply
select it.</p>
<p>We want to make add a new view as an additional sub-tab in the view that
currently has the <cite>Annotations</cite> and <cite>Usage</cite>, tabs near the upper right
corner8. Once you are in the <cite>Individuals by class</cite> tab select
<cite>Window&gt;Views&gt;Individual views&gt;Individuals by type (inferred)</cite>. This will
give you a blue outline of the new view. As you move the outline around
the existing window it will change depending how you move it, indicating
how it will fit into the existing tab after you click. When the blue
outline looks like figure 5.2 click left and you will see the new view
added as another sub-tab.</p>
<p>After you click your UI should now look similar to figure 5.3. If you
clicked somewhere else you can just go to the new view and delete it by
clicking the <cite>X</cite> in the upper right corner of the view and then redo it
and position it correctly. At first it may seem a bit unintuitive but
after you do it a few times it becomes very easy to position new views.</p>
<p>With this new view you can see the instances of each class displayed
beneath the class. Each class can be expanded or contracted to view or
hide its particular instances. Since we don’t have many instances in our
ontology yet the usefulness of this new view isn’t that obvious but as
we add more instances and as you deal with larger real ontologies in the
future, this view can be very helpful to find specific instances of a
class. Note that the UI just shows the most direct class (or classes)
that the Individual is an instance of. For example, we currently just
have three individuals, the three instances of <code class="docutils literal notranslate"><span class="pre">Spiciness</span></code>: <code class="docutils literal notranslate"><span class="pre">Hot</span></code>, <code class="docutils literal notranslate"><span class="pre">Medium</span></code>,
and <code class="docutils literal notranslate"><span class="pre">Mild</span></code>. These are also instances of <code class="docutils literal notranslate"><span class="pre">owl:Thing</span></code> (as are <em>all</em> instances)
however the UI only displays them as instances of <code class="docutils literal notranslate"><span class="pre">Spiciness</span></code> since it is
implicit that they are also instances of all the superclasses of
<code class="docutils literal notranslate"><span class="pre">Spiciness</span></code>.</p>
<figure class="align-center align-default" id="id34">
<img alt="_images/26.png" class="no-scaled-link" src="_images/26.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 5.2 Adding a new view to the Individuals by class tab</em></span><a class="headerlink" href="#id34" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id34" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-center align-default" id="id35">
<img alt="_images/32.png" class="no-scaled-link" src="_images/32.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 5.3 A Customized Individuals by class tab</em></span><a class="headerlink" href="#id35" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id35" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p><strong>Exercise 28: Create Example Pizza Individuals</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>We will now add our first actual Pizza.
Remain in the <cite>Individuals by class</cite> tab.</p></li>
<li><p>Use the <cite>Class hierarchy</cite> view in the upper left to navigate to
<cite>MargheritaPizza</cite> and select it. There is a view directly under the <cite>Class hierarchy tab</cite>
called <cite>Direct instances</cite>. Click the little diamond in that
view. This will prompt you for the name of your new individual. Call it
<cite>MargheritaPizza1</cite>.</p></li>
<li><p>Your UI should now look similar to figure 5.4.</p></li>
</ol>
<hr class="docutils" />
<figure class="align-center align-default" id="id36">
<img alt="_images/41.png" class="no-scaled-link" src="_images/41.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 5.4 Creating Our First Pizza</em></span><a class="headerlink" href="#id36" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id36" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p><strong>Exercise 29: Assign a Data Property Values</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Remain in the <cite>Individuals by class</cite> tab. Click on <cite>MargheritaPizza1</cite>.
You should see in the Description view that it is an instance of
<code class="docutils literal notranslate"><span class="pre">MargheritaPizza</span></code>. Now you will use the <cite>Property assertions</cite> view to set
the caloric content of <code class="docutils literal notranslate"><span class="pre">MargheritaPizza1</span></code>. This view can be used to set
object and data properties.</p></li>
<li><p>Click on the <cite>(+)</cite> icon next to <cite>Data property assertions</cite> in the
<cite>Property assertions</cite> view in the lower right.</p></li>
<li><p>Use the pop-up window to select the data property <cite>hasCaloricContent</cite>.
Then enter 263 as the value and use the menu at the bottom to define the
value’s datatype to be <cite>xsd:integer</cite>. Note: this is different than what
you did in exercise 27. In exercise 27 you defined the datatype for the
<em>property</em>. Here you are defining the datatype for <em>a specific value</em>.
It would be nice if Protégé could just infer the datatypes for you but
because datatype definitions can be complex this is harder than it might
seem so you need to make sure to explicitly define the datatype for each
value. As you get into more realistic ontologies you will often use
tools such as Cellfie (described in <a class="reference internal" href="#chap8"><span class="std std-ref">Chapter 8</span></a>) to load your individual
data automatically and those tools can automatically add datatype
information for each individual as part of the loading process.</p></li>
<li><p>Your UI should now look similar to figure 5.5. Select <cite>OK</cite> to enter
the new value. Run the reasoner.</p></li>
</ol>
<hr class="docutils" />
<figure class="align-center align-default" id="id37">
<img alt="_images/51.png" class="no-scaled-link" src="_images/51.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 5.5 hasCaloricContent for MargheritaPizza1</em></span><a class="headerlink" href="#id37" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id37" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<div class="pitfall admonition">
<p class="admonition-title">Warning</p>
<p>One of the most common sources of errors in ontologies is to have
the wrong datatype for data property values. The sooner you catch
these errors, the easier they are to debug so it is a good idea
to run the reasoner frequently after you enter any values. Note
that in some versions of Protégé 5.5. there is a minor bug where
the UI may lock up due to an inconsistent data value (e.g., a
string value in a property typed for integer). If this happens
the best thing to do is save your work if possible, quit Protégé,
and then restart it. When you restart it fix the datatype errors
<em>before</em> you run the reasoner and then run the reasoner to make
sure you actually have fixed the error.</p>
</div>
<p><strong>Exercise 30: Create More Instances and Data Property Values</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Remain in the <cite>Individuals by class</cite> tab. Click on other <code class="docutils literal notranslate"><span class="pre">Pizzas</span></code> and
create instances of them (apx. 5-10) and then fill in their caloric
content with values ranging from 200 to 800. Try to have about half
of your pizzas higher than 400 calories and half less than 400. The
UI retains the datatype from the previous use so once you define the
first caloric content you shouldn’t need to set the datatype again
but it is always a good idea to make sure it is correct, in this
case: <code class="docutils literal notranslate"><span class="pre">xsd:integer</span></code>.</p></li>
<li><p>It is a good idea to adhere to an intuitive naming standard for
your instances such as &lt;Class Name&gt;&lt;Number&gt; as we did for
<code class="docutils literal notranslate"><span class="pre">MargheritaPizza1</span></code>. Depending on the classes you instantiate your
pizzas should have names like <code class="docutils literal notranslate"><span class="pre">MargheritaPizza2</span></code>, <code class="docutils literal notranslate"><span class="pre">SohoPizza1</span></code>, etc.</p></li>
<li><p>Make sure to create an instance of <code class="docutils literal notranslate"><span class="pre">AmericanaPizza</span></code> called
<code class="docutils literal notranslate"><span class="pre">AmericanaPizza1</span></code> that <code class="docutils literal notranslate"><span class="pre">hasCaloricContent</span></code> 723.</p></li>
<li><p>Make sure to run the reasoner after creating all your instances.</p></li>
</ol>
<hr class="docutils" />
<p><strong>Exercise 31: Create a Datatype Restriction that Every Pizza hasCaloricContent</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Navigate to the <cite>Classes</cite> major tab.</p></li>
<li><p>Select the <cite>Pizza</cite> class.</p></li>
<li><p>Click on the <cite>(+)</cite> icon next to the <cite>SubClass Of</cite> field in the <cite>Description</cite>
view. This time let’s use the <cite>Data restriction</cite> tab. Navigate to and
select <cite>hasCaloricContent</cite> in the <cite>Restricted property</cite> view. In the
<cite>Restriction filler</cite> view scroll down to <cite>xsd:integer</cite> and select it. The
Restriction type should be set to the default which is <cite>Some</cite>. If it isn’t
use the menu to change it. Your UI should look like figure 5.6. Click
<cite>OK</cite>.</p></li>
<li><p>Note that you also could have selected <cite>Exactly 1</cite> because a Pizza can
only have one caloric content but since you already defined the property
to be functional this isn’t necessary and either <cite>Some</cite> or <cite>Exactly 1</cite> have
the same effect. Just as Protégé usually provides several ways to enter
the same information in the user interface OWL often provides different
ways to provide the same information in your model. The nice thing is
the reasoner lets you not worry so much about which way you do it, as
long as your definitions are consistent.</p></li>
</ol>
<hr class="docutils" />
<p>We have now stated that every PizzahasCaloricContent and that content
must be an integer. In addition to using the predefined set of datatypes
we can further specialize the use of a datatype by specifying
restrictions on the possible values. For example, it is easy to specify
a range of values for a number.</p>
<figure class="align-center align-default" id="id38">
<img alt="_images/61.png" class="no-scaled-link" src="_images/61.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 5.6 Defining the hasCaloricContent data property restriction</em></span><a class="headerlink" href="#id38" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id38" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Using the datatype property, we have created, we will now create defined
classes that specify a range of interesting values. We will define a
<code class="docutils literal notranslate"><span class="pre">HighCaloriePizza</span></code> to be any pizza that has a calorific value equal to or
higher than 400.</p>
<p><strong>Exercise 32: Create a HighCaloriePizza Defined Class</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>Navigate to the <cite>Classes</cite> tab.</p></li>
<li><p>Select the <cite>Pizza</cite> class. Create a subclass of <cite>Pizza</cite> called <cite>HighCaloriePizza</cite>.</p></li>
<li><p>Make sure <cite>HighCaloriePizza</cite> is selected. Click on the <cite>(+)</cite> icon next to
the <cite>SubClass Of</cite> field in the <cite>Description</cite> view. In the Class expression
editor type <cite>hasCaloricContent some xsd:integer[&gt;= 400]</cite> and click <cite>OK</cite>.</p></li>
<li><p>Make sure <cite>HighCaloriePizza</cite> is still selected and use
<cite>Edit&gt;Convert to defined class</cite> to make it a defined class.</p></li>
<li><p>Repeat steps 1-4 but this time create a subclass of <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> called
<cite>LowCaloriePizza</cite> and make its definition be: <cite>hasCaloricContent some xsd:integer[&lt; 400]</cite>.</p></li>
<li><p>Run the reasoner. You should now see that each instance of <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> that
<code class="docutils literal notranslate"><span class="pre">hasCaloricContent</span></code> greater than or equal to 400 is classified as a
<code class="docutils literal notranslate"><span class="pre">HighCaloriePizza</span></code> and similarly those with less than 400 as
<code class="docutils literal notranslate"><span class="pre">LowCaloriePizza</span></code>. See the <cite>Description</cite> view in figure 5.7.</p></li>
</ol>
<hr class="docutils" />
<figure class="align-center align-default" id="id39">
<img alt="_images/71.png" class="no-scaled-link" src="_images/71.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 5.7 High Calorie Pizzas</em></span><a class="headerlink" href="#id39" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id39" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<h1 id="adding-order-to-an-enumerated-class"><span id="chap6"></span><span class="sectnum">6. </span>Adding Order to an Enumerated Class<a class="headerlink" href="#adding-order-to-an-enumerated-class" title="Permalink to this heading">¶</a></h1>
<p>In this chapter we will expand on the enumerated class that we created
to model spiciness in <a class="reference external" href="#defining-an-enumerated-class">section 4.14</a>.
This chapter will highlight some of the power of object properties in
OWL. We are going to create an ordering for the instances of
<code class="docutils literal notranslate"><span class="pre">Spiciness</span></code>. I.e., <code class="docutils literal notranslate"><span class="pre">Hot</span> <span class="pre">isSpicierThan</span> <span class="pre">Medium</span></code> which <code class="docutils literal notranslate"><span class="pre">isSpicierThan</span> <span class="pre">Mild.</span></code> To
start go to the <cite>Object properties</cite> tab. Create a new property that is a
sub-property of
<cite>owl:topObjectProperty</cite>. Call this property <cite>isSpicierThan</cite>. Make its
domain and range the <cite>Spiciness</cite> class. Make the property transitive.
Transitive means that if X <code class="docutils literal notranslate"><span class="pre">isSpicierThan</span></code> Y and Y <code class="docutils literal notranslate"><span class="pre">isSpicierThan</span></code> Z then
X <code class="docutils literal notranslate"><span class="pre">isSpicierThan</span></code> Z. This is of course similar to the greater than and
less than relations in math. Create another property called
<cite>isMilderThan</cite>. Make one property the inverse of the other. It doesn’t
matter which one, you only have to specify that one property is the
inverse of another, and the reasoner will realize that both are
inverses. Run the reasoner. You will see that the reasoner has
inferred the domain and range for <code class="docutils literal notranslate"><span class="pre">isMilderThan</span></code> than as well as the
fact that it is transitive and the inverse of <code class="docutils literal notranslate"><span class="pre">isSpicierThan</span></code>.</p>
<figure class="align-center align-default" id="id40">
<img alt="_images/112.png" class="no-scaled-link" src="_images/112.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 6.1 Setting isSpicierThan property in the Individuals by class tab</em></span><a class="headerlink" href="#id40" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id40" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Next go back to the <cite>Individuals by class</cite> tab. Go to the <cite>Individuals by type (inferred)</cite> view.
You should see the individuals that exist right
now. So far we have the example Pizzas you created and the instances
of Spiciness: <code class="docutils literal notranslate"><span class="pre">Hot</span></code>, <code class="docutils literal notranslate"><span class="pre">Medium</span></code>, and <code class="docutils literal notranslate"><span class="pre">Mild</span></code>. Click on <cite>Hot</cite>. Notice that in the
Property assertions view in the lower right corner the title should
now say: <cite>Property assertions: Hot</cite>. Click on the <cite>(+)</cite> icon next to
<cite>Object property assertions</cite>. You will be prompted with a form with two
areas to input values. The name of the property goes in the left hand
side and the value in the right hand side (see figure 6.1). Type in
<cite>isSpicierThan</cite> as the name of the property. Remember you can use
auto-complete so you should only need to type <em>isS</em> and type
<cite>&lt;control&gt;&lt;space&gt;</cite> and Protégé will fill in the name of the property.
Enter <cite>Medium</cite> as the value. Your UI should look similar to figure 6.1.
Select <cite>OK</cite>. Now click on <cite>Medium</cite> and set its <code class="docutils literal notranslate"><span class="pre">isSpicierThan</span></code> value to be
<code class="docutils literal notranslate"><span class="pre">Mild</span></code>. That is all the data entry you need to do. Now run the reasoner
again and click on the <code class="docutils literal notranslate"><span class="pre">Hot</span></code>, <code class="docutils literal notranslate"><span class="pre">Medium</span></code>, and <code class="docutils literal notranslate"><span class="pre">Mild</span></code> individuals. You should
see that all the additional <code class="docutils literal notranslate"><span class="pre">isSpicierThan</span></code> and <code class="docutils literal notranslate"><span class="pre">isMilderThan</span></code> values have
been filled in for you because the reasoner knows that the two
properties are inverses and transitive. For example, <code class="docutils literal notranslate"><span class="pre">Mild</span></code>, which we
didn’t edit at all, should have two values for <code class="docutils literal notranslate"><span class="pre">isMilderThan</span></code> filled in
by the reasoner.</p>
<p>We can use these properties in various ways to reason about the relative
spiciness of things. We will show some examples in <a class="reference internal" href="#chap8"><span class="std std-ref">Chapter 8</span></a>.</p>
<div class="notes admonition">
<p class="admonition-title">Notes</p>
<p>This concludes the basics of designing classes and properties
with Protégé. There is also a web version of Protégé available at
<a class="reference external" href="https://webprotege.stanford.edu">https://webprotege.stanford.edu</a>/# This takes you to a page where
you can create an account by providing an email and creating a
password. Web Protégé supports multiple users and has extra
capabilities such as threaded discussions for collaborative
development of ontologies. However, it currently does not support
any reasoners, so it is a good idea to bring ontologies developed
in WebProtégé into the desktop version to run the reasoner and
validate the ontology. See <a class="reference internal" href="#chap12"><span class="std std-ref">Chapter 12</span></a> for more on Web Protégé.</p>
</div>
<h1 id="names-iri-s-labels-and-namespaces"><span id="chap7"></span><span class="sectnum">7. </span>Names: IRI’s, Labels, and Namespaces<a class="headerlink" href="#names-iri-s-labels-and-namespaces" title="Permalink to this heading">¶</a></h1>
<p>In exercise 2 we set up some parameters regarding new entity names and
rendering without much of an explanation. The concept of a <em>name</em> in OWL
is a little complex so we wanted to wait until you had a basic grasp of
an ontology before diving into these details.</p>
<p>To start with remember that every entity in your ontology has a unique
Internationalized Resource Identifier (IRI). An IRI is similar to a
URL. In fact, a URL is a kind of IRI. I.e., all URLs are IRIs but many
IRIs are not URLs. A URL is typically meant to identify a specific page
meant to be viewed in a browser. An IRI is often at a smaller level of
granularity and for <em>any</em> kind of resource, not only those meant to be
viewed in a browser. If you go to the <cite>Active ontology</cite> tab in Protégé you
will see the <cite>Ontology IRI</cite> for your ontology. This is the base IRI that
all entities have in common. In addition, each entity has a subsequent
part that comes after the base IRI that uniquely identifies the IRI for
the entity.</p>
<p>You can see this by clicking on any entity and starting (but don’t
complete) the <cite>Refactor&gt;Rename entity</cite> command. Click on the <cite>Pizza</cite> class.
Then select <cite>Refactor&gt;Rename entity</cite>. You will get a pop-up window with
the current name: <cite>Pizza</cite>. However, this is only the final part of the
IRI. To see the full IRI click on the check box in the lower right
corner that says: <cite>Show full IRI</cite>. Your full IRI will be different but it
will look something like: <cite>http://www.semanticweb.org/pizzatutorial/ontologies/2020/PizzaTutorial#Pizza</cite>.
Uncheck the <cite>Show full IRI</cite> box and then <cite>Cancel</cite> the rename command.</p>
<p>If you recall from exercise 2 there are two options when you create a
new entity. One is to use a user supplied name. That is the option that
you should have selected at the beginning of the tutorial and that
should be active now. The other is to use an auto-generated name. This
option creates a Universally Unique Identifier (UUID) for the IRI of
each entity. A UUID is an ID that is generated by an algorithm and is
guaranteed to be unique. There are also two ways to display an entity.
One way is to use the last part of the IRI that typically comes after a
# sign as in the <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> example above. The other is to use an annotation
property called a label. An annotation property is meant to provide
meta-data about an entity.</p>
<div class="line-block">
<div class="line">Object and data property values can only be asserted on Individuals.
However, since all entities have meta-data annotation properties can
be asserted on to any entity. There are some annotation properties
that are included by default with any Protégé ontology. You can see
these by looking at the <cite>Annotation properties</cite> tab. Note that just as
with other properties you can also add your own annotation properties
but they should be used for meta-data not for regular data. You will
see <code class="docutils literal notranslate"><span class="pre">rdfs:label</span></code> is one of the default annotation properties. When you
use UUIDs for your entity IRIs then by default Protégé will</div>
<div class="line">automatically use the name you type in for a new entity in the
<code class="docutils literal notranslate"><span class="pre">rdfs:label</span></code> annotation property.</div>
</div>
<p>Although you can also configure Protégé to use other properties if you
wish, using the same dialog for entity rendering that you used in
exercise 2.</p>
<p>There are advantages and disadvantages to both options and there are
options in between such as using both user supplied names for IRIs and
using <code class="docutils literal notranslate"><span class="pre">rdfs:label</span></code> for more intuitive names. The details can get
complicated and there also isn’t universal agreement within the
community as to which is generally better. For your first ontology and
since you will be using SPARQL I chose to use user supplied entity names
because it is the simpler option and is especially better for SPARQL
queries as you will see in the
next section. Which option you choose for your ontology will depend on
the specific requirements you have as well as the standards established
by your organization or organizations that you work with.</p>
<p>Finally, another name related concept you should be aware of is the
concept of a namespace. If you have worked with most modern
programming languages such as Python or Java, you are already familiar
with the concept of a namespace. The concept is identical in OWL. A
namespace is used to avoid naming conflicts between different
ontologies. For example, you may have a class called <code class="docutils literal notranslate"><span class="pre">Network</span></code> in an
ontology about telecommunications. You might also have a class called
<code class="docutils literal notranslate"><span class="pre">Network</span></code> in an ontology about graph theory. The two concepts are
related but are different. Just as with programming languages you use
namespace prefixes to determine what specific namespace a name refers
to. E.g., in this example you might have the prefix <code class="docutils literal notranslate"><span class="pre">tc</span></code> for the Telecom
ontology and <code class="docutils literal notranslate"><span class="pre">gt</span></code> for the Graph Theory ontology. Thus, when you referred
to the Network class for the Telecom ontology you would use <code class="docutils literal notranslate"><span class="pre">tc:Network</span></code>
and <code class="docutils literal notranslate"><span class="pre">gt:Network</span></code> for the graph theory class.</p>
<p>Note that you already have some experience with other namespaces. The
OWL namespace prefix is <code class="docutils literal notranslate"><span class="pre">owl</span></code> and is used to refer to classes such as
<code class="docutils literal notranslate"><span class="pre">owl:Thing</span></code> and <code class="docutils literal notranslate"><span class="pre">owl:Nothing</span></code>. The Resource Description Framework Schema
(RDFS) is a model that OWL is built on top of and thus some properties
that ontologies use such as <code class="docutils literal notranslate"><span class="pre">rdfs:label</span></code> leverage this namespace.</p>
<p>In the bottom view of the <cite>Active ontology</cite> tab there is a tab called
<cite>Ontology Prefixes</cite>. This tab shows all the current namespace mappings in
your ontology. There are certain concepts from OWL, RDF, RDFS, XML and
XSD that are required for every ontology, so those namespaces are by
default mapped in every new Protégé ontology. There is also a mapping to
the empty string for whatever the namespace is for your ontology. This
allows you to display and refer to entities in your ontology without
entering a namespace prefix. If you look at that tab now you should see
a row where the first column is blank, and the second column has the
base IRI for your ontology. It should be the same IRI as the
<a href="#id2"><span class="problematic" id="id3">`</span></a>Ontology IRI <a href="#id4"><span class="problematic" id="id5">`</span></a>at the top of the Active ontology tab, except it also has a # sign
at the end. E.g., the Pizza tutorial developed for this tutorial has an
IRI of: <a class="reference external" href="http://www.semanticweb.org/pizzatutorial/ontologies/2020/PizzaTutorial">http://www.semanticweb.org/pizzatutorial/ontologies/2020/PizzaTutorial</a>
and the row that has a blank first column in Ontology Prefixes has the IRI: <a class="reference external" href="http://www.semanticweb.org/pizzatutorial/ontologies/2020">http://www.semanticweb.org/pizzatutorial/ontologies/2020</a>/PizzaTutorial#.</p>
<h1 id="a-larger-ontology-with-some-individuals"><span id="chap8"></span><span class="sectnum">8. </span>A Larger Ontology with some Individuals<a class="headerlink" href="#a-larger-ontology-with-some-individuals" title="Permalink to this heading">¶</a></h1>
<p>The rest of the tutorial requires some data loaded into your ontology.
So far, we have mostly been dealing with defining classes and
properties. This type of information is known in the semantic web
community as T-Box information. The T stands for Terminological.
Individuals or instances are known as A-Box. The A stands for
Assertional as in specific facts that are asserted about the domain.
Typically, there will be a much larger amount of A-Box information than
T-Box. The A-Box information is often uploaded from spreadsheets,
relational databases or other sources. One tool that is not covered in
this tutorial that is useful is called Cellfie. Cellfie is a tool that
can take data from spreadsheets and upload it into an ontology mapping
the table-based data into objects and property values. For a tutorial on
Cellfie see: <a class="reference external" href="https://github.com/protegeproject/cellfie-plugin/wiki/Grocery-Tutorial">https://github.com/protegeproject/cellfie-plugin/wiki/Grocery-Tutorial</a></p>
<p>In addition to using Cellfie, you can use the <cite>Individuals by class</cite> tab introduced in chapter 5
to create new instances and to create object and
data property values for those instances as you did with the <code class="docutils literal notranslate"><span class="pre">Hot</span></code> and
<code class="docutils literal notranslate"><span class="pre">Medium</span></code> individuals in <a class="reference internal" href="#chap6"><span class="std std-ref">Chapter 6</span></a>. However, that can be tedious so to
spare you that uninteresting work I’ve developed a version of the Pizza
ontology that has many individuals already created. That ontology should
be identical to the ontology you have developed so far except with many
additional individuals.
You can find this populated Pizza ontology at: <a class="reference external" href="https://tinyurl.com/PizzaWDataV2">https://tinyurl.com/PizzaWDataV2</a>
Go to this URL and download the file to your local machine and then use <cite>File&gt;Open</cite>.
Before you do that, it is probably a good
idea to close the current file so that there is no possible confusion
between the Pizza ontology you developed and the new one with extra
data.</p>
<h2 id="get-familiar-with-the-larger-ontology"><span class="sectnum">8.1. </span>Get Familiar with the Larger Ontology<a class="headerlink" href="#get-familiar-with-the-larger-ontology" title="Permalink to this heading">¶</a></h2>
<figure class="align-center align-default" id="id41">
<img alt="_images/113.png" class="no-scaled-link" src="_images/113.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 8.1 Graph of Some of the New Ontology Classes and Individuals</em></span><a class="headerlink" href="#id41" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id41" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Figure 8.1 uses the <cite>OntoGraf</cite> tab to visualize some of the new additions
to the ontology. There is a new class called <code class="docutils literal notranslate"><span class="pre">Person</span></code> with subclasses
<code class="docutils literal notranslate"><span class="pre">Employee</span></code> and <code class="docutils literal notranslate"><span class="pre">Customer</span></code>. Employee has 5 individuals: <code class="docutils literal notranslate"><span class="pre">Manager</span></code>, <code class="docutils literal notranslate"><span class="pre">Chef</span></code>,
<code class="docutils literal notranslate"><span class="pre">Waiter1</span></code>, and <code class="docutils literal notranslate"><span class="pre">Waiter2</span></code>. Customer has 10 instances.</p>
<p>In addition, if you look at the <cite>Object properties</cite> tab you will see there
are some new properties:</p>
<ul class="simple">
<li><p>The property <code class="docutils literal notranslate"><span class="pre">purchasedByCustomer</span></code> has domain <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> and range
<code class="docutils literal notranslate"><span class="pre">Customer</span></code>. It maps from an individual <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> to the <code class="docutils literal notranslate"><span class="pre">Customer</span></code> that purchased it.
It has an inverse called <code class="docutils literal notranslate"><span class="pre">purchasedPizza</span></code>.</p></li>
<li><p>The property <code class="docutils literal notranslate"><span class="pre">hasSpicinessPreference</span></code> has domain <code class="docutils literal notranslate"><span class="pre">Customer</span></code> and range <code class="docutils literal notranslate"><span class="pre">Spiciness</span></code>.
It records the preference the <code class="docutils literal notranslate"><span class="pre">Customer</span></code> has for how spicy they usually like their <code class="docutils literal notranslate"><span class="pre">Pizza</span></code>.</p></li>
</ul>
<p>The <cite>Data properties</cite> tab also shows some new properties:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">hasDiscount</span></code> data property has a domain of <code class="docutils literal notranslate"><span class="pre">Customer</span></code> and a range of <code class="docutils literal notranslate"><span class="pre">xsd:decimal</span></code>.
This records the discount (if any) that the <code class="docutils literal notranslate"><span class="pre">Customer</span></code> will get on their next purchase.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">numberOfPizzasPurchased</span></code> data property has a domain of <code class="docutils literal notranslate"><span class="pre">Customer</span></code> and a range of
<code class="docutils literal notranslate"><span class="pre">xsd:integer</span></code>. It records the number of <code class="docutils literal notranslate"><span class="pre">Pizzas</span></code> that each customer has purchased.</p></li>
<li><p>The ssn property has a domain of <code class="docutils literal notranslate"><span class="pre">Employee</span></code> and a range of <code class="docutils literal notranslate"><span class="pre">xsd:string</span></code>.
It maps from an <code class="docutils literal notranslate"><span class="pre">Employee</span></code> to their social security number. In the United States this is a number that all employers
must have in order to process things such as insurance contributions and tax information.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">hasPhone</span></code> data property has a domain of <code class="docutils literal notranslate"><span class="pre">Person</span></code> and a range of <code class="docutils literal notranslate"><span class="pre">xsd:string</span></code>.</p></li>
</ul>
<p>Most of these data properties have additional constraints in addition to
their ranges. For example, a discount can only be between 0 and 1 and a
phone number and social security number must correspond to a certain
format.</p>
<p>Many of these constraints could be expressed via DL axioms that define
the range. However, for reasons that will be discussed below, it is
often better to represent data integrity constraints using the SHACL
language rather than as DL axioms. The general rule of thumb is that DL
axioms are for reasoning and SHACL is for data integrity constraints. Of
course, this begs the question what is the difference between reasoning
and integrity constraints and the distinction is by nature a fuzzy one.
However, there are guidelines that we will discuss in the section on
SHACL which we hope will help shed some light on the difference.</p>
<p>Finally, viewing the <cite>Individuals by class</cite> tab will help to understand
the additional data in the ontology. If you go to that tab, you will see
many new individuals. In addition to <code class="docutils literal notranslate"><span class="pre">Employees</span></code> and <code class="docutils literal notranslate"><span class="pre">Customers</span></code> there are
instances of the <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> class. You can see all these individuals in the
<cite>Individuals by type (inferred)</cite> view in the upper right corner.</p>
<p>Now with more instances you can see the value of the <cite>Individuals by type (inferred)</cite> view.
You can expand and contract various classes and
see the instances for them. Notice that the 4
<code class="docutils literal notranslate"><span class="pre">HighCaloriePizzas</span></code> are also instances of <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> but they aren’t shown
under <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> because all instances of <code class="docutils literal notranslate"><span class="pre">HighCaloriePizza</span></code> are always
instances of the <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> class. There is only one instance of the <code class="docutils literal notranslate"><span class="pre">Pizza</span></code>
class displayed because all the other instances of <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> are also
instances of subclasses of <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> so they are shown under those
subclasses rather than under <code class="docutils literal notranslate"><span class="pre">Pizza</span></code>. If there are two or more classes
that an Individual is an instance of that aren’t subclasses of each
other then they will all be shown. For example, <code class="docutils literal notranslate"><span class="pre">MargheritaPizza1</span></code> is an
instance of both <code class="docutils literal notranslate"><span class="pre">MargheritaPizza</span></code> and <code class="docutils literal notranslate"><span class="pre">LowCaloriePizza</span></code> and it shows up
under each class because neither is a subclass of the other. It is
possible for a <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> to be a <code class="docutils literal notranslate"><span class="pre">LowCaloriePizza</span></code> and not be a
<code class="docutils literal notranslate"><span class="pre">MargheritaPizza</span></code> and vice-versa.</p>
<figure class="align-center align-default" id="id42">
<img alt="_images/27.png" class="no-scaled-link" src="_images/27.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 8.2 Viewing the New Instances in the Individuals by Class tab</em></span><a class="headerlink" href="#id42" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id42" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<h1 id="queries-description-logic-and-sparql"><span id="chap9"></span><span class="sectnum">9. </span>Queries: Description Logic and SPARQL<a class="headerlink" href="#queries-description-logic-and-sparql" title="Permalink to this heading">¶</a></h1>
<p>Now that we have some individuals in our ontology, we can do some
interesting queries. There are several tools for doing queries in
Protégé.</p>
<h2 id="description-logic-queries"><span class="sectnum">9.1. </span>Description Logic Queries<a class="headerlink" href="#description-logic-queries" title="Permalink to this heading">¶</a></h2>
<p>To start with the most straight forward one based on what you have
already learned are Description Logic (DL) queries. These are
essentially the same kind of statements you have been using to define
classes. However, in addition to using such statements to define a
class you can use it as a query.</p>
<p><strong>Exercise 33: Try Some Description Logic Queries</strong></p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>To begin with navigate to the DL Query tab. If it doesn’t exist
create it using: <cite>Window&gt;Tabs&gt;DL</cite> Query.</p></li>
<li><p>At the top right of this tab you should see a view that says
<cite>DL query:</cite> and below it <cite>Query (class expression)</cite>.</p></li>
<li><p>You can enter any DL statement you want in this box and then see all
the entities that are subclasses, superclasses, and instances of it. As
an example, enter: <cite>Customer and purchasedPizza some (hasTopping some (hasSpiciness value Hot))</cite>.
I.e., all <code class="docutils literal notranslate"><span class="pre">Customers</span></code> who have purchased a
<code class="docutils literal notranslate"><span class="pre">Pizza</span></code> that <code class="docutils literal notranslate"><span class="pre">hasSpiciness</span> <span class="pre">Hot</span></code>. At first you may not see anything but don’t
worry there is one more step.</p></li>
<li><p>Look at the check boxes on the right under <cite>Query for</cite>. Check
<cite>Superclasses</cite>, <cite>Subclasses</cite> (although it should already be checked by
default) and <cite>Instances</cite>. Now your UI should look like figure 9.1. You may
notice that <code class="docutils literal notranslate"><span class="pre">owl:Nothing</span></code> shows up as a subclass. Don’t worry that is
actually expected. Remember that <code class="docutils literal notranslate"><span class="pre">owl:Nothing</span></code> is the empty set and the
empty set is a subset of every set (including itself) so just as
<code class="docutils literal notranslate"><span class="pre">owl:Thing</span></code> is a superclass of every class <code class="docutils literal notranslate"><span class="pre">owl:Nothing</span></code> is a subclass of
every class. If you don’t want to see <code class="docutils literal notranslate"><span class="pre">owl:Nothing</span></code> you can uncheck the
box toward the bottom right that says <cite>Display owl:Nothing</cite>.</p></li>
<li><p>Try some additional DL queries such as:
<cite>hasTopping some (hasSpiciness value Hot) and VegetarianPizza and (hasTopping some (hasSpiciness some (isMilderThan value Hot)))</cite>.
Note that with this last query you are taking advantage
of the transitive order you defined for the instances of the <code class="docutils literal notranslate"><span class="pre">Spiciness</span></code>
class in <a class="reference internal" href="#chap6"><span class="std std-ref">Chapter 6</span></a>.</p></li>
<li><p>You can also do queries for strings in the names of your entities.
For example, first do a query simply with <cite>Pizza</cite> in the query window.
Then type in Hot in the <cite>Name contains</cite> field. This should give you all
the classes and individuals with <em>Hot</em> in their name.</p></li>
</ol>
<hr class="docutils" />
<figure class="align-center align-default" id="id43">
<img alt="_images/114.png" class="no-scaled-link" src="_images/114.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 9.1 The DL Query Tab</em></span><a class="headerlink" href="#id43" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id43" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<h2 id="sparql-queries"><span class="sectnum">9.2. </span>SPARQL Queries<a class="headerlink" href="#sparql-queries" title="Permalink to this heading">¶</a></h2>
<p>SPARQL is a powerful language, and one could write a whole book about
it. In fact, there are books written about it. The best one I have
seen is the O’Reilly book Learning SPARQL by Bob DuCharme.
This is an excellent book that not only goes into SPARQL but into topics
such as RDF/RDFS and how triples are used to represent all information
in OWL. I will only touch on those issues here, there is much more to
say about them and DuCharme’s book is a great place to learn more. If
some of the following is a bit hard to understand don’t be discouraged.
This is just an attempt to give a very high level introduction to
something that requires significant study to really understand.</p>
<p>Essentially SPARQL is to the Semantic Web and Knowledge Graphs as SQL is
to relational databases. Just as SQL can do more than just query, it can
also assert new information into a database, so SPARQL can as well. The
current SPARQL plugins for Protégé are somewhat limited and don’t
support the statements such as INSERT for entering new data so we will
just cover the basics of using SPARQL as a query language but keep in
mind there is a lot more to it than what we briefly cover here.</p>
<h3 id="some-sparql-pizza-queries"><span class="sectnum">9.2.1. </span>Some SPARQL Pizza Queries<a class="headerlink" href="#some-sparql-pizza-queries" title="Permalink to this heading">¶</a></h3>
<p>To start with go to the <cite>SPARQL Query</cite> tab. If it isn’t already there
you can as always add it using <cite>Window&gt;Tabs&gt;SPARQL Query</cite>. This tab
consists of two views, the top which holds the query and the bottom
which holds the results. There should be some text already there. It
may look confusing, but we’ll explain it. Just to start with hit the
<cite>Execute</cite> button at the bottom of the tab. You should see a bunch of
classes and class expressions returned.</p>
<p>To understand what is going on you first need to understand that each
SPARQL query consists of two parts. The first part at the beginning
consists of several namespace prefixes. These statements consist of the
prefix used for a particular namespace as well as the IRI associated
with this namespace. Recall that these concepts were described in
<a class="reference internal" href="#chap7"><span class="std std-ref">Chapter 7</span></a>. You may be wondering where all these prefixes came from since
you didn’t add them to your ontology. The answer is that every OWL
ontology comes with a set of namespaces and prefixes that are required
to define the ontology.</p>
<p>Also, to understand SPARQL you need to “peak under the hood” of OWL. So
far, we have been discussing concepts in purely logical and set
theoretic terms, i.e., at the semantic level. However, like any language
or database there is a lower level that describes how the concepts are
mapped to actual data. In a relational database the fundamental
construct to represent data is a table. In OWL the fundamental construct
is a triple. OWL is actually built on top of RDFS which is a language
built on top of RDF. RDF (Resource Description Framework) is a language
to describe graphs (in the mathematical sense of the term). I.e., to
describe nodes and links.</p>
<p>The foundation for RDF graphs are triples consisting of a subject,
predicate, and object. This results in what is called an undirected or
network graph because objects can be subjects and vice versa. Whenever
you define a property in OWL you are defining a predicate. An individual
can be a subject or an object (or both). E.g., in our ontology
<code class="docutils literal notranslate"><span class="pre">Customer1</span> <span class="pre">purchasedPizza</span> <span class="pre">AmericanaHotPizza1</span></code>. In this example <code class="docutils literal notranslate"><span class="pre">Customer1</span></code> is
the subject, <code class="docutils literal notranslate"><span class="pre">purchasedPizza</span></code> is the predicate and <code class="docutils literal notranslate"><span class="pre">AmericanaHotPizza1</span></code> is
the object.</p>
<p>However, classes and properties themselves are also represented as
triples. So for example, when you create the class <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> what Protégé
does for you is to add the triple: <code class="docutils literal notranslate"><span class="pre">Pizza</span> <span class="pre">rdf:type</span> <span class="pre">owl:Class</span></code> to the
ontology. I.e., the <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> entity is of type (is an instance of)
<code class="docutils literal notranslate"><span class="pre">owl:Class</span></code>. Similarly when you add <code class="docutils literal notranslate"><span class="pre">NamedPizza</span></code> as a subclass of <code class="docutils literal notranslate"><span class="pre">Pizza</span></code>,
Protégé adds the triple: <code class="docutils literal notranslate"><span class="pre">NamedPizza</span> <span class="pre">rdfs:subClassOf</span> <span class="pre">Pizza</span></code>.</p>
<p>Hopefully, now you can make some sense of this initial query. The query
is looking for all the entities that are the subjects of triples where
the predicate is <code class="docutils literal notranslate"><span class="pre">rdfs:subClassOf</span></code> and the object is any other
entity. The <em>?</em> before a name indicates that the name is a wildcard that
can match anything that fits with the rest of the pattern. This is part
of the power of SPARQL, one can match a Subject, an Object, a Predicate
or even all three. Making all 3 parts of the pattern wildcards would
return every triple in the graph (in this case our entire Pizza
ontology) being searched. You may notice that in some cases the object
is simply the name of a class while in others it is a class expression
with an orange circle in front of it. This is because when defining
classes using DL axioms Protégé creates anonymous classes that
correspond to various DL axioms.</p>
<p>The SELECT part of a SPARQL query determines what data to display. The
WHERE part of a query determines what to match in the query. If you want
to display everything matched in the WHERE clause you can just use a *
for the SELECT clause. The initial default query in this tab is set up
with no knowledge of the specific ontology. I.e., it will return all the
classes that are subclasses of other classes regardless of the ontology.
To get information about <code class="docutils literal notranslate"><span class="pre">Pizzas</span></code> the first thing we need to do is to add
another prefix to the beginning of the query. In our case the Pizza
ontology has been set up with a mapping to the prefix pizza (you can see
this in the ontology prefixes tab in the Active ontology tab discussed
in <a class="reference internal" href="#chap7"><span class="std std-ref">Chapter 7</span></a>). So, add the following to the SPARQL query after the last
PREFIX statement:</p>
<p><cite>PREFIX pizza: &lt;http://www.semanticweb.org/pizzatutorial/ontologies/2020/PizzaTutorial#&gt;</cite></p>
<p>We are almost ready to query the actual ontology. For our first query
let’s find all the Pizzas purchased by a Customer. The SPARQL code for
this is:</p>
<p><cite>SELECT * WHERE { ?customer pizza:purchasedPizza ?pizza }</cite></p>
<p>Type that into the query window underneath the prefixes (of course
remove the existing query). Hit <cite>Execute</cite>. Your screen should look similar
to figure 9.2.</p>
<figure class="align-center align-default" id="id44">
<img alt="_images/28.png" class="no-scaled-link" src="_images/28.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
<em>Figure 9.2 A SPARQL Query</em></span><a class="headerlink" href="#id44" title="Permalink to this image">¶</a></span><a class="headerlink" href="#id44" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>If you examine the output carefully you may notice an issue. <code class="docutils literal notranslate"><span class="pre">Customer4</span></code>
only seems to have purchased 2 Pizzas. However, if you examine the data
in the <cite>Individuals by class</cite> tab you will see that she purchased 3.
The reason that one of them doesn’t show up is that when the data was
entered, I typically entered it on the <code class="docutils literal notranslate"><span class="pre">Customer</span></code> instances. However, for
one of <code class="docutils literal notranslate"><span class="pre">Customer4's</span> <span class="pre">Pizzas</span></code> I entered the data on the <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> instead. I.e.,
I asserted on <code class="docutils literal notranslate"><span class="pre">HotVeggiePizza2</span></code> that it was <code class="docutils literal notranslate"><span class="pre">purchasedByCustomer</span> <span class="pre">Customer4</span></code>.
Since <code class="docutils literal notranslate"><span class="pre">purchasedPizza</span></code> and <code class="docutils literal notranslate"><span class="pre">purchasedByCustomer</span></code> are inverses, the reasoner
filled in the additional information for me. However, SPARQL doesn’t pay
attention to information asserted by the reasoner only information
asserted by the user. Note: this depends on the implementation of
SPARQL. For example, there is another SPARQL implementation available as
a Protégé plugin called Snap SPARQL that is aware of reasoner
inferences.</p>
<p>However, in the default SPARQL tab that we are using, SPARQL ignores
information asserted by the reasoner. This is an issue for other plugins
for Protégé as well such as the Individuals matrix. Luckily, there is a
simple work around for this issue where information asserted by the
reasoner can be saved and reloaded so that it is the same as user
defined data. This workaround is described in my blog in the article:
<a class="reference external" href="https://www.michaeldebellis.com/post/export-inferred-axioms">https://www.michaeldebellis.com/post/export-inferred-axioms</a></p>
<p>To further see this, replace the current query (make sure to keep all the prefixes) with:</p>
<p><cite>SELECT * WHERE { ?pizza pizza:purchasedByCustomer ?customer}</cite></p>
<p>This will show you the two pizzas where the purchase relation was
asserted on the instance of Pizza rather than on the instance of
Customer.</p>
<p>Suppose you wanted to see all of the things that are objects of
<code class="docutils literal notranslate"><span class="pre">Customer</span></code>? With a couple of new constructs this is simple. First, in
SPARQL a shortcut to identify the type of any entity is to use the
keyword a as the predicate. This is just shorthand for <code class="docutils literal notranslate"><span class="pre">rdf:type</span></code>. Second,
when you have multiple statements in a WHERE clause you need to end each
one with a period.</p>
<p>Replace the current query with the following:</p>
<div class="line-block">
<div class="line"><cite>SELECT *</cite></div>
<div class="line"><cite>WHERE { ?customer a pizza:Customer.</cite></div>
<div class="line"><cite>?customer ?relation ?relatedToCustomer.}</cite></div>
</div>
<p>This will provide a long list of everything in the graph that is an
object of some instance of the Customer class. I.e., any entity that
is the object of a predicate with a <code class="docutils literal notranslate"><span class="pre">Customer</span></code> as the subject.</p>
<p>Suppose you wanted to count the number of Pizzas purchased by Customers
so far. For this you use the SPARQL function COUNT. Here is what it
would look like:</p>
<div class="line-block">
<div class="line"><cite>SELECT (COUNT(?pizza) AS ?pcount)</cite></div>
<div class="line"><cite>WHERE {?customer pizza:purchasedPizza ?pizza}</cite></div>
</div>
<p>Paste that into the SPARQL query view and hit <cite>Execute</cite> and you should
see the returned value: 15. However, remember this isn’t really all
the <code class="docutils literal notranslate"><span class="pre">Pizzas</span></code> because a few of the purchases were recorded on the <code class="docutils literal notranslate"><span class="pre">Pizza</span></code>
rather than on the <code class="docutils literal notranslate"><span class="pre">Customer</span></code>. To get the full number we can take
advantage of the fact that we have recorded the number of pizzas that
each customer has purchased and use the SPARQL SUM function. That
query would be:</p>
<div class="line-block">
<div class="line"><cite>SELECT (SUM(?pnumber) AS ?psum)</cite></div>
<div class="line"><cite>WHERE { ?customer pizza:numberOfPizzasPurchased ?pnumber}</cite></div>
</div>
<p>This should give you the correct number of 17.</p>
<h3 id="sparql-and-iri-names"><span class="sectnum">9.2.2. </span>SPARQL and IRI Names<a class="headerlink" href="#sparql-and-iri-names" title="Permalink to this heading">¶</a></h3>
<p>If you recall, at the beginning of the tutorial we changed the
preference for creating new entities to <em>user supplied name</em> rather
than <em>auto-generated name</em> which is the default. Now that you have
seen examples of using SPARQL we can explain why. With auto-generated
names rather than have names such as <code class="docutils literal notranslate"><span class="pre">Customer</span></code> or <code class="docutils literal notranslate"><span class="pre">purchasedByCustomer</span></code>
our entities would have names such as
<code class="docutils literal notranslate"><span class="pre">OWLPropertyA4257yri73ff90rmbx</span></code> and <code class="docutils literal notranslate"><span class="pre">OWLClass23gkb0tk5kd30tm</span></code>. Thus, the
first query would be something like:</p>
<p><code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">*</span> <span class="pre">WHERE</span> <span class="pre">{?customer</span> <span class="pre">pizza:OWLPropertyA4257yri73ff90rmbx</span> <span class="pre">?pizza}</span></code></p>
<p>and the second query would be:</p>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">*</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">WHERE</span> <span class="pre">{?customer</span> <span class="pre">a</span> <span class="pre">pizza:OWLClass23gkb0tk5kd30tm.</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">?customer</span> <span class="pre">?relation</span> <span class="pre">?relatedToCustomer.}</span></code></div>
</div>
<p>This would be much less intuitive than the user defined names. There are
good reasons to use autogenerated names, especially for large ontologies
that are implemented in multiple natural languages.
However, for new users, especially those who plan to use SPARQL and
SHACL, I think it is more intuitive to start with user supplied names
and then progress to auto-generated names if and when the requirements
show a true need for them. This approach to developing software
incrementally rather than to attempt to design the perfect system that
can scale for all possible future requirements is known as the Agile
approach to software development. In my experience Agile methods have
proven themselves in countless real-world projects to deliver better
software on time and on budget than the alternative waterfall approach.
For more on Agile methods see: <a class="reference external" href="https://www.agilealliance.org/agile101/">https://www.agilealliance.org/agile101/</a></p>
<p>This just gives you a basic overview of some of the here is a lot more
and if you are interested you should check out DuCharme’s book or some
of the many SPARQL tools and tutorials on the web. Some of these are in
the bibliography.</p>
<p>One final point: features of OWL and SWRL that new users frequently find
frustrating are the Open World Assumption (OWA) and lack of
non-monotonic reasoning. The OWA was discussed in <a class="reference external" href="#automated-classification-and-open-world-reasoning">section 4.13</a>.
Non-monotonic reasoning will be discussed in <a class="reference external" href="#owa-and-monotonic-reasoning">section 11.1</a>.
For now, though remember that SPARQL is <em>not</em> subject to <em>either</em> of these
restrictions. With SPARQL one can do non-monotonic reasoning and
leverage the more common Closed World Assumption (CWA). E.g., one can
test if the value for a property on a specific instance exists or not
and can take actions if that property does not exist.</p>
<p>To perform non-monotonic reasoning simply requires a combination of
INSERT and DELETE in the same query. One deletes the existing triple
and inserts a triple with the same subject and predicate but a
different object. Unfortunately, this is not possible to currently
demonstrate in Protégé because neither of the implementations in
Protégé support INSERT or DELETE. I plan to add some SPARQL utilities
to my blog at some point in the future that provide examples of this.
For an example of how SPARQL can be used to get around the OWA see the
ontology and instructions I recently added to my blog at: <a class="reference external" href="https://www.michaeldebellis.com/post/the-people_example-ontology">https://www.michaeldebellis.com/post/the-people_example-ontology</a>
In that example I show how the defined class <code class="docutils literal notranslate"><span class="pre">Hermit</span></code> defined as a <code class="docutils literal notranslate"><span class="pre">Person</span></code> with a maximum of 0 social relations can’t be
recognized by the reasoner due to the OWA. However, a simple SPARQL
query can both recognize instances of the <code class="docutils literal notranslate"><span class="pre">People</span></code> class with no social
relations and can change the type of such instances (<code class="docutils literal notranslate"><span class="pre">?p</span></code>) by adding the
triple: <code class="docutils literal notranslate"><span class="pre">?p</span> <span class="pre">rdf:type</span> <span class="pre">:Hermit</span></code>. This new post also has a much more
interesting example SPARQL query developed with Franz Inc. and their
AllegroGraph product. The query utilizes linked data to find the
median income for the area that Barack Obama was born by querying
several different public knowledge graphs such as DBpedia and
Geonames.</p>
<h1 id="swrl-and-sqwrl"><span id="chap10"></span><span class="sectnum">10. </span>SWRL and SQWRL<a class="headerlink" href="#swrl-and-sqwrl" title="Permalink to this heading">¶</a></h1>
<p>The Semantic Web Rule Language (SWRL) was created because there are
certain kinds of inferences that can’t be done by Description Logic (DL)
axioms. Also, in my experience there are also times where an inference
can be done using DL, but it can be more intuitive to define that
inference as a rule.</p>
<p>There are actually two UI’s for SWRL in Protégé. There is the SWRL tab
and there is also a Rules view that can be added to the UI as we added a
view in section 8.2. The SWRL tab is the one that is being more actively
developed and I recommend you always use that. This chapter will focus
on the SWRL tab. Everything in this chapter applies to the SWRL tab and
will be slightly different in the Rules view. For an overview of the
Rules view see the SWRL Process Modeling tutorial listed at the end of
this chapter.</p>
<div class="line-block">
<div class="line">Like all rule systems, SWRL consists of a left-hand side (called the
antecedent) and a right-hand side (called the consequent). The two are
separated by an arrow created with a dash and a greater than character
like this: -&gt;. Each expression in a SWRL rule is separated by a ^
sign. The consequent of the rule fires if and only if <em>every</em>
expression in the antecedent is satisfied. Since the antecedent can be
satisfied multiple times, this means that SWRL rules can do iteration.
They will fire for every</div>
<div class="line">combination of values that can satisfy the antecedent. All parameters
(variables that are wildcards and get bound dynamically as the rule
fires) are preceded by a ?.</div>
</div>
<div class="line-block">
<div class="line">SWRL expressions consist of 3 types:</div>
<div class="line">1.Class expressions. This is the name of a class followed by
parentheses with a parameter inside.</div>
</div>
<blockquote>
<div><p>For example Customer(?c) will bind ?c to an instance of the class
Customer and (assuming the rest of the antecedent is satisfied) will
iterate over each instance of the Customer class.</p>
<p>2.Property expressions. This is the name of a property followed by
parentheses and two parameters: the first for the individual that is
being tested and the second to bind to the value of that property for
that individual. Note that since individuals can have more than one
value for a property this can also create iteration, where the rules
will iterate over every property value for each individual.</p>
<p>E.g., purchasedPizza(?c, ?p) will bind ?p to each Pizza purchased by
each customer ?c.</p>
<div class="line-block">
<div class="line">3.Built-in functions. SWRL has a number of built-in functions for
doing mathematical tests, string tests, etc. The SWRL built-ins are
documented here: <a class="reference external" href="https://www.w3.org/Submission/SWRL/">https://www.w3.org/Submission/SWRL/</a>
All SWRL built-ins are prefaced by the swrlb prefix. E.g., the math built-in</div>
<div class="line">swrlb:greaterThan(?np, 1) succeeds if the value of ?np is greater
than 1.</div>
</div>
</div></blockquote>
<p>We are going to add two simple SWRL rules to our Pizza ontology to
compute discounts for some Customers. We are assuming that our Pizza
restaurant hasn’t been in business long, so they want to give a discount
to anyone who has purchased more than one Pizza. Also, their manager
overestimated the love of spicy ingredients of their customers, and they
have a lot of Jalapeno peppers that they want to use before they go bad,
so they are offering a larger discount to customers who prefer Hot
pizzas rather than those who prefer Medium or Mild.</p>
<p>To begin with let’s write the first rule to give a 20% discount to all
customers who have purchased more than 2 Pizzas and prefer Hot Pizzas.</p>
<p><strong>Exercise 34: Write Your First SWRL Rule</strong></p>
<p>_____________________________________________________________________________________</p>
<div class="line-block">
<div class="line">1. To begin with navigate to or create the SWRLTab. If it doesn’t
already exist use</div>
<div class="line">Window&gt;Tabs&gt;SWRLTab to create and select it. If you don’t have the
SWRLTab under the</div>
<div class="line">Window&gt;Tabs menu then use File&gt;Check for plugins and select the
SWRLTab plugin. Remember if you do this you need to restart Protégé
for the plugin to be available.</div>
</div>
<p>2. The SWRLTab is divided into two main views and then some buttons on
the bottom of the tab that relate to DROOLS. The question of when and
how to use DROOLS confuses many new users but there is a simple answer:
don’t use it! As you get more experience with SWRL you will start to
understand how and when DROOLS is used but for beginners the answer is
simple. Think of all those DROOLS buttons as things for power users
only. You don’t need to use them at all. That is why we installed the
Pellet reasoner in section 4.2. The Pellet reasoner supports SWRL and
when you run the reasoner it will also automatically run any SWRL rules
you have. See the bibliography for a paper on DROOLS.</p>
<p>3. Click on the New button at the bottom of the top view. The other
buttons should be grayed out since they only apply if you have at least
one rule written. This will give you a new pop-up window to write your
rule. In the Name field at the top call the rule: HotDiscountRule. You
can skip the comment but if you want to add a comment it is a good habit
to get into and you can write something like: Provide a special discount
for customers who prefer hot pizzas.</p>
<div class="line-block">
<div class="line">4. Now go to the bottom part of the rule window and start writing the
rule. To start you want to bind a parameter to each instance of the
Customer class. To do this all you need to do is to write:</div>
<div class="line">Customer(?c). Note that auto-complete should work in this window but
sometimes it may not and you may need to type the complete name. Also,
you will see various hints or error messages in the Status field as
you type which you can mostly ignore for now. E.g., as you type out
Customer you will see messages like: Invalid SWRL atom predicate ‘Cus’
until you complete the name of the Customer class. Those messages can
help you understand why your rule won’t parse as you develop more
rules but for now you should be able to ignore them.</div>
</div>
<p>5. Now you want to bind a parameter to the number of Pizzas that each
customer has ordered so far. To do that you first add a ^ character.
This stands for the logical <em>and</em>. I.e., the rule will fire for every
set of bindings that satisfy <em>all</em> of the expressions in the antecedent.
To test the number of Pizzas you use the data property
numberOfPizzasPurchased. So at this point your rule should look like:
Customer(?c) ^ numberOfPizzasPurchased(?c, ?np).</p>
<p>6. Now we want to test the object property hasSpicinessPreference. The
first parameter will also be ?c. I.e., we are iterating through each
instance of Customer, binding it to ?c and then testing the values of
these properties. However, in this case rather than binding the
spiciness preference to a parameter we just want to test if it is equal
to the instance of SpicinessHot. So we directly reference that instance
in the expression resulting in: ^ hasSpicinessPreference(?c, Hot).</p>
<p>7. As the last part of the antecedent we want to test that the Customer
has purchased more than 1 Pizza. We can use the SWRL math built-in
swrlb:greaterThan. Add ^ swrlb:greaterThan(?np, 1) That is the last
part of the antecedent so we write -&gt; to signal the beginning of the
consequent. At this point your rule should look like: Customer(?c) ^
numberOfPizzasPurchased(?c, ?np) ^ hasSpicinessPreference(?c, Hot) ^
swrlb:greaterThan(?np, 1) -&gt;</p>
<p>8. Finally, we write the consequent of the rule, the part after the
arrow that signifies what to do each time the rule succeeds. We want to
give these customers a 20% discount so we write: hasDiscount(?c, 0.2).
Whereas the expressions on the left hand side are tests to see if the
rule should fire, the expression on the right is an assertion of a new
value to be added to the ontology. For those with a logic background the
simple way to think of this is that the antecedent is implicitly
universally quantified whereas the consequent is implicitly
existentially quantified.</p>
<p>9. Thus the whole rule should look like: Customer(?c) ^
numberOfPizzasPurchased(?c, ?np) ^ hasSpicinessPreference(?c, Hot) ^
swrlb:greaterThan(?np, 1) -&gt; hasDiscount(?c, 0.2). Take note that the OK
button at the bottom is only possible to select when the rule has a
valid syntax. It should be selectable now so select it. You should see
the new rule show up at the top of the top most view.</p>
<p>_____________________________________________________________________________________</p>
<p>Note that there is a minor bug in SWRL where sometimes the prefix for
the current ontology will be added to all the expressions without a
prefix. So at some point you may see that your expressions end up
looking like this: pizza:Customer(?c). If this happens don’t worry it
won’t affect the way the rule works at all. If at some point this
happens and you want to remove the prefixes there is a way to do this
described in my blog:</p>
<p>Next, we we Pizza but don’t prefer Hot Pizzas.</p>
<p><strong>Exercise 35: Write Another SWRL Rule</strong></p>
<p>_____________________________________________________________________________________</p>
<p>1. Make sure you are still in the SWRLTab. Click on the HotDiscountRule
and select Clone</p>
<p>2. This should bring up the same window you used to create your first
rule with the code for that rule in the window. Change the name of this
rule from S1 to LessSpicyDiscountRule.</p>
<p>3. Next edit the test for the Customer’s spiciness preference. Rather
than just testing if it is Hot we want to test this time if it
isMilderThan Hot. This is an example of using the order relation we
defined in chapter 6. Change hasSpicinessPreference(?c, Hot) to
hasSpicinessPreference(?c, ?spr). Rather than just test if it is equal
to Hot we need to bind the preference value to the parameter ?spr. Then
after this add the usual and character and the new test, so you should
add: ^ isMilderThan(?spr, Hot)</p>
<p>4. Finally, we want to change the discount for these Customers to be 10%
rather than 20%. So change the consequent to be: hasDiscount(?c, 0.1).</p>
<p>5. Thus the whole rule should look like: Customer(?c) ^
numberOfPizzasPurchased(?c, ?np) ^ hasSpicinessPreference(?c, ?spr) ^
isMilderThan(?spr, Hot) ^ swrlb:greaterThan(?np, 1) -&gt; hasDiscount(?c,
0.1).</p>
<p>_____________________________________________________________________________________</p>
<p>Now we want to run our rules. Remember there is no need to use those
DROOLS buttons. Just synchronize the reasoner and your rules should fire
just as other DL axioms that assert values based on
inverses, defined classes, etc. Go back to the Individuals by class tab
and look at various Customers. For example, Customer1 has ordered more
than one Pizza and hasSpicinessPreference of Hot so she has a discount
of .2. Note that as with any information asserted by the reasoner, there
is a ? next to the assertion which you can click on and it will provide
an explanation about why the value was asserted. This explanation will
list the appropriate rule that fired and the values that caused it to
fire. If you look at Customer6, you will see that he has no discount
because he has only purchased one Pizza. Finally, if you look at
Customer2, she has a discount of .1 because she has purchased more than
one Pizza but her spiciness preference isMilderThanHot.</p>
<p>In this case the consequent of our rule was to add a data property
assertion to an individual. Another possible outcome is to make an
individual be an instance of a new class. E.g., if we had a subclass of
Customer called PreferredCustomer and we wanted the result of a rule be
to make a Customer an instance of PreferredCustomer we could have -&gt;
PreferredCustomer(?c) as the consequent of the rule.</p>
<p>A tool that is useful to debug SWRL rules is the Semantic Query-Enhanced
Web Rule Language or SQWRL (pronounced squirrel). SQWRL rules look just
like SWRL rules except in the consequent there is a sqwrl:select
statement that lists every parameter that we want to know the value of
every time the rule fires.</p>
<p><strong>Exercise 36: Write a SQWRL Rule</strong></p>
<p>_____________________________________________________________________________________</p>
<p>1. Bring up the SQWRLTab if it doesn’t already exist using
Windows&gt;Tabs&gt;SQWRLTab. You will see it looks almost identical to the
SWRLTab.</p>
<p>2. Let’s say we want to see how often the HotDiscountRule fires. We can
find this out very easily. To start select the HotDiscountRule and clone
it. This creates a copy of the rule called S1. Select that rule and then
select the Edit button.</p>
<p>3. Change the name of the rule to TestHotDiscountRule. Replace the
consequent (the expression after the arrow) with the following:
sqwrl:select(?c, ?np) and select OK. Your SQWRL rule should look like:
Customer(?c) ^ numberOfPizzasPurchased(?c, ?np) ^
hasSpicinessPreference(?c, pizza:Hot) ^ swrlb:greaterThan(?np, 1) -&gt;
sqwrl:select(?c, ?np). Synchronize the reasoner.</p>
<p>4. Select TestHotDiscountRule then select the Run button at the bottom
of the tab. This will create a new tab in the lower view called
TestHotDiscountRule. You should see that the rule fired 3 times with ?c
equal to Customer4, Customer1, and Customer8 and with ?np equal to 3, 2,
and 2.</p>
<p>_____________________________________________________________________________________</p>
<p>This has been a very brief introduction to SWRL. For a somewhat more
interesting example based on process modeling see: <a class="reference external" href="https://www.michaeldebellis.com/post/swrl_tutorial">https://www.michaeldebellis.com/post/swrl_tutorial</a></p>
<p>Chapter 11 SHACL</p>
<p>Next, we will look at a plugin for SHACL. SHACL stands for Shapes
Constraint Language. Note that <em>shape</em> in this context has nothing to do
with geometric shapes. SHACL is somewhat newer than the other
technologies described here. However, it fills an essential gap in the
Semantic Web architecture stack, and it is gaining a lot of traction in
the world of large-scale corporate development. The reason for SHACL may
at first seem a bit hard to grasp. After all many of the constraints
that SHACL can define for data can also be defined using Description
Logic or SWRL which are more high level and a bit easier to use. So why
even bother with SHACL? There are two reasons that SHACL is essential
for real world use of Semantic Web and Knowledge Graph technology:</p>
<p>1.The need to define constraints that aren’t limited by the Open World
Assumption (OWA) and Monotonic reasoning.</p>
<p>2.The fact that real world data is <em>messy!</em></p>
<div class="line-block">
<div class="line">11.1 OWA and Monotonic Reasoning</div>
<div class="line">As described in section 4.13 OWL uses the Open World Assumption (OWA)
because it was designed for the Internet. However, the OWA makes
certain kinds of constraint validation difficult or impossible. For
example, it is common to have a data integrity constraint that all
employees must have a social security number. While such an axiom can
be defined in OWL it will seldom work when we want it to because of
the OWA. The OWA means that there may be a social security number out
there somewhere in the Internet but that the system just hasn’t found
it yet. While this is true, to validate the integrity of corporate
data just saying “well it is out there somewhere” won’t do. To
validate data integrity we need to be able to fire off warnings when
required data isn’t there so we need to use the Closed World
Assumption (CWA).</div>
</div>
<p>Monotonic reasoning is a byproduct of the fact that OWL and SWRL are
based on logic. The OWL reasoners are essentially theorem provers. If
you have ever studied mathematical proofs, you know that one of the
classic ways to prove that something is invalid is to show that some
variable has two different values. E.g., if our theorem implies that p =
True and p = False then we have a contradiction. Each variable can only
have one value. This is why SWRL rules can only add values to variables
rather than change them. For more on this see the excellent presentation
on SWRL by Martin O’Connor: <a class="reference external" href="https://protege.stanford.edu/conference/2009/slides/SWRL2009ProtegeConference.pdf">https://protege.stanford.edu/conference/2009/slides/SWRL2009ProtegeConference.pdf</a></p>
<p>This is why SPARQL often needs to be used rather than SWRL even though SWRL is more abstract and powerful. SWRL does not support non-monotonic reasoning whereas SPARQL does. Similarly, when validating data, we may want to take actions to change it, e.g., to coerce it into a proper standard format. To do that we need to change rather than add a value, i.e., we need non-monotonic reasoning.</p>
<div class="line-block">
<div class="line">11.2 The Real World is Messy</div>
<div class="line">The other reason for SHACL is that real world data is messy. Over the
span of this tutorial, you may have experienced a point where you made
an error, and the reasoner marked your ontology as invalid. If you
haven’t, congratulations, but as you work with Protégé more you will
experience it. This is another by product of using a logic-based
language. Simply having one inconsistency makes the entire model
invalid. For small examples this is not a problem. When one has tens,
hundreds, or even thousands of individuals it isn’t that difficult to
find the problem and fix it. However, when dealing with Big Data where
one has tens of thousands, millions, or more individuals the
prevalence of bad data may be huge.</div>
</div>
<p>I.e., it might be the case that we never get the data to satisfy every
integrity constraint which would mean the reasoner is never of any use
except to tell us that the ontology is not consistent.</p>
<p>Thus, SHACL provides a way to define data integrity constraints that
overlap to some degree with what can be defined in OWL and SWRL. For
example, both can define the number of values allowed for a specific
property. E.g., that each instance of Employee must have one and only
one social security number (ssn). If this were defined as a DL axiom,
then the axiom would never fire for employees that had no ssn because of
the OWA. On the other hand, if an Employee accidentally had 2 ssn values
then the entire ontology would be inconsistent until one value was
removed. SHACL on the other hand can handle both these examples and
rather than making the entire ontology inconsistent it simply logs
warnings at various levels of severity.</p>
<div class="line-block">
<div class="line">11.3 Basic SHACL Concepts</div>
<div class="line">To understand SHACL recall that the language underlying OWL is RDF
which describes graphs as triples of the form: Subject Predicate
Object. SHACL also works at the level of RDF because some developers
may want to simply use that lower level for reasons of efficiency.
Thus, RDF can validate an RDF graph as well as an OWL ontology.
Fundamentally, SHACL consists of two components:</div>
</div>
<blockquote>
<div><p>1. An RDF vocabulary for defining data constraints on RDF graphs
(which includes OWL since an OWL ontology is an RDF graph).</p>
<ol class="arabic simple" start="2">
<li><p>A reasoner for applying the constraints defined in 1 to a specified data graph such as the Pizza ontology.</p></li>
</ol>
</div></blockquote>
<p>One of the most important classes in 1 is a SHACL Shape. An instance of
the SHACL Shape class consists of a set of Targets and Constraints. A
Target defines which nodes in the RDF graph that the data constraints
apply to. For OWL ontologies this is typically the name of a class which
indicates that the constraints apply to all instances of that class. The
Constraints define the specific property for the constraint as well as
the actual constraints such as the minimum or maximum number of values
and the datatype. In the following example, a Target is the Employee
class in the Pizza ontology. An example constraint is that the ssn
property must have exactly one value. Another example constraint is that
the format of the ssn value must be a string of the form: “NNN-NN-NNNN”
where each N must be an integer. For more on SHACL see the references in
the bibliography.</p>
<div class="line-block">
<div class="line">11.4 The Protégé SHACL Plug-In</div>
<div class="line">To start go to Windows&gt;Tabs and see if you have SHACL Editor as an
option. If you don’t then go to File&gt;Check for plugins and select the
SHACL4Protege Constraint Validator. You need to restart Protégé to see
the new plugin so save your work and then quit and start Protégé and
load the Pizza ontology with data.</div>
</div>
<p>Because editing SHACL is a bit more complex for this version of the
tutorial we are only going to view some already written SHACL
constraints and see how the validator processes them rather than writing
additional constraints. First download the PizzaShapes.txt file to your
local hard drive. This file can be found at: <a class="reference external" href="https://tinyurl.com/pizzatshapes">https://tinyurl.com/pizzatshapes</a>
Once you have downloaded the file open the SHACL Editor: Window&gt;</p>
<p>You will see an example shapes file in the editor when it opens but that
isn’t the shapes file you are looking for. From the editor click on the
Open button at the top of the tab and navigate to the PizzaShapes.txt
file you downloaded.</p>
<p>There are two shapes in this file, one for the Employee class and one
for the Customer class. So, we want to expand only the Person class in
the Class hierarchy view. We will start with the Employee class so
select that class which should result in all the instances of Employee
being displayed in the view below it.</p>
<p>For the SHACL Editor we want the bottom view in the middle to take up as
much screen real estate as possible. So, to start we can delete the two
views on the far right side of the tab by clicking on the X at the top
of each tab.</p>
<p>Then drag the SHACL Editor view over to the left just enough so you can
see the Employee and Customer classes and their instances. Your UI
should look similar to figure 11.1.</p>
<p>To begin examine the code in the SHACL Editor view. Note that at the
beginning there are a list of namespaces, similar to the namespace
prefixes in the SPARQL editor. After the prefixes there is the first
actual shape which is the EmployeeShape. This shape constrains values of
properties on instances of Employee. The sh:targetClass identifies the
class that this shape is for. Beneath that are various nodes (as in
nodes in a graph, SHACL is also represented as triples) that constrain
various properties that apply to the Employee class. The first node
constrains the cardinality of the ssn property to be exactly one
(minCount 1 and maxCount1). The next also applies to ssn and constrains
the data further than just saying it must be a string. It must be a
string that matches the pattern: “^\d{3}-\d{2}-\d{4}$” This is a
regex expression that means the pattern must be 3 digits (numeric
characters from 0-9), followed by a dash, followed by 2 digits, followed
by a dash, followed by 4 digits.</p>
<p>The next 2 nodes deal with the hasPhone data property. This property
must have at least one value (although possibly more) and must also
conform to a similar pattern of 3 digits followed by a dash followed by
3 digits followed by a dash followed by 4 digits. Of course, actual
phone numbers can be more complex and varied but this is just a simple
example.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/image97.png"><img alt="_images/image97.png" src="_images/image97.png" style="width: 6.5in; height: 4.40417in;" /></a>
</figure>
<p>Figure 11.1 The SHACL Editor</p>
<p>Now hit the Validate button. You should see several messages displayed
in the long SHACL constraint violations view at the bottom. If you had
the Employee class selected when you clicked on Validate, then this view
should now read: SHACL constraint violations: 5/8. This means that there
were 8 constraint violations and 5 of them were on instances of the
Employee class. You can see the violations that apply to each Employee
by clicking on each individual. You can resize the various columns in
this view which is helpful to view the information you need. The most
useful data is in the Message, Path, and Value columns. All the other
columns such as Severity and Source can be made as small as possible to
make more room for those other columns. If you do this and click on the
Chef individual you will see that she has one constraint violation. See
figure 11.2.</p>
<p>You can see that the Chef individual has 2 values for the ssn property
which is more than allowed. If you examine the Chef individual in the
Individuals by class view you will see that this is indeed the case.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/image98.png"><img alt="_images/image98.png" src="_images/image98.png" style="width: 6.5in; height: 4.42361in;" /></a>
</figure>
<p>Figure 11.2 Constraint Violation for the Chef Individual</p>
<p>If you click on the Manager individual, you will see that he has a
constraint violation because his phone number is not in the proper
format. Waiter1 has a similar problem. Waiter2 has missing data. Her
hasPhone and ssn data properties both must have values but don’t.</p>
<p>If you move your focus to the Customer class, you can see the remaining
3 constraint violations.</p>
<p>Customer10’shasDiscount property is greater than 1 which is not allowed.
This is defined by the CustomerShape in the hasDiscount node with
sh:minInclusive 0.0 and sh:maxInclusive 1.0. This is the way you define
a minimum and maximum value for a numeric property (note: this applies
to the value not to the number of values). Customer2 also has a hasPhone
value that doesn’t match the defined format and finally Customer3 does
not have a value for hasPhone when at least one is required.</p>
<p>Recall that the SHACL constraints themselves are essentially RDF graphs.
Figures 11.3 and 11.4 illustrate the Employee shape and the Customer
shape used in the above example as graphed in the Gruff tool from
AllegroGraph.</p>
<blockquote>
<div><figure class="align-default">
<a class="reference internal image-reference" href="_images/image99.png"><img alt="_images/image99.png" src="_images/image99.png" style="width: 4.85417in; height: 4.41389in;" /></a>
</figure>
</div></blockquote>
<p>Figure 11.3 Gruff Visualization of the EmployeeShape</p>
<blockquote>
<div><figure class="align-default">
<a class="reference internal image-reference" href="_images/image100.png"><img alt="_images/image100.png" src="_images/image100.png" style="width: 5.125in; height: 3.725in;" /></a>
</figure>
</div></blockquote>
<p>Figure 11.4 Gruff Visualization of the CustomerShape</p>
<div class="line-block">
<div class="line">This is just the most basic introduction to SHACL. For a more
sophisticated tutorial see the Top Quadrant tutorial: Also, this
presentation:</div>
<div class="line">more detail on SHACL.</div>
</div>
<p>Chapter 12 Web Protégé</p>
<p>This tutorial has primarily focused on the desktop version of Protégé
because as of this writing Web Protégé doesn’t support any reasoners so
the majority of the sophisticated capabilities of OWL and Protégé such
as defined classes and SWRL rules can’t be created in Web Protégé.
However, one of my goals in creating this tutorial was to address
questions that I’ve seen frequently asked on the Protégé user support
email list and one of the most common question is the difference between
Protégé and Web Protégé. We are all used to using tools as services
rather than applications installed on our local machines, so people
often go to Web Protégé as their default. While Web Protégé lacks
reasoner support it can still be extremely useful for collaborative
development. This chapter explains the benefits of Web Protégé and some
best practices for using the two tools together.</p>
<p>To begin it is recommended that new users start with the desktop version
of Protégé. The constraints imposed on the ontology by lack of a
reasoner are significant and if one learns only using Web Protégé they
will miss many of the benefits of OWL and come away with the idea that
Protégé is little more than a traditional object modeling tool. However,
once one is familiar with the desktop version it is worth getting
familiar with Web Protégé as it can be extremely useful for joint
development of an ontology by 2 or more people.</p>
<p>To begin there are two options for Web Protégé:</p>
<blockquote>
<div><div class="line-block">
<div class="line">1.Use the Stanford server at <em>webprotege.stanford.edu</em></div>
<div class="line">2.Download and install the Web Protégé software on your own local
server.</div>
</div>
</div></blockquote>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/image101.png"><img alt="_images/image101.png" src="_images/image101.png" style="width: 5.19861in; height: 3.03056in;" /></a>
</figure>
<p>Figure 12.1 Web Protégé Projects</p>
<p>Unless you have security requirements at your organization that prohibit
you from using the hosted version at Stanford it is best to start with
the Stanford server. I won’t go into the details of how to install a
local Web Protégé server because either way the functionality is the
same. To start, let’s create a project in Web Protégé for the Pizza
tutorial with data ontology. When you first go to
<em>webprotege.stanford.edu</em> you will be prompted to create a user ID (your email address) and a
password. Once you do that you should have a fresh Web Protégé
workspace. Figure 12.1 shows what my Web Protégé workspace currently
looks like. Most of the projects are owned by me although note that the
CODO project is owned by my colleague Biswanath Dutta. However, I still
have complete access to that ontology due to the way Biswanath has
configured my access as being able to both view and edit the ontology.</p>
<p>To upload the Pizza ontology, select the large Create New Project
button. This will bring up the window shown in figure 12.2. Fill out the
project name and description, then select the Choose File button and
navigate to where you have the latest version of the Pizza tutorial with
data. Note that in the figure I have already done this navigation so
there is a value for the file to load. You can leave the Language field
blank. Once you have all the fields set up similar to figure 12.2 click
the Create New Project button on this dialog (note this is a different
button than the one you started from).</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/image102.png"><img alt="_images/image102.png" src="_images/image102.png" style="width: 5.11667in; height: 4.34306in;" /></a>
</figure>
<p>Figure 12.2 The Create New Project Dialog</p>
<p>Your workspace should now include your first project. Click on the three
horizontal bars at the far right of the project. This should bring up a
pop-up menu. Select the Open option. This should bring you into the main
Web Protégé UI to browse an ontology.</p>
<p>Before you make changes to the ontology you need to make sure the
settings for new entities and rendering are consistent with the settings
you used for the Pizza ontology. The default in Web Protégé as with
Protégé is to use Auto-Generated UUIDs rather than user supplied names.
If you aren’t sure about these settings you can go back to exercise 2 at
the beginning of chapter 4 and chapter 7 to refresh your memory. There
are excellent reasons to use auto-generated UUIDs but for beginners,
especially for those who want to learn SPARQL, I think they make
learning the basics more difficult so we have been using the alternative
of user supplied names. At the top of the Web Protégé UI in the right
corner there are various links: Display, Project, Share,… Click on Project. This will
give you a dropdown menu. Select Settings from that menu. Scroll down to
New Entity Settings. Change IRI Suffix from Auto-generated Universally
Unique ID (UUID) to Supplied name. Leave the rest of the settings as
they are and select the Apply button at the bottom right corner of the
screen.</p>
<p>When you select Apply, you should return to the main Web Protégé view
with the Class hierarchy tab selected. If it doesn’t select that tab.
Select the Pizza class. Your UI should look like figure 12.3.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/image103.png"><img alt="_images/image103.png" src="_images/image103.png" style="width: 6.5in; height: 4.43472in;" /></a>
</figure>
<p>Figure 12.3 Browsing the Pizza Ontology in Web Protégé</p>
<p>Note that the axioms for the Pizza class are there but they are not
editable. Protégé uses the reasoner even when entering or editing axioms
to ensure that any axioms have the proper syntax so since there is no
reasoner in Web Protégé it is not possible to edit axioms (since one
might introduce syntactically incorrect axioms) only delete them using
the X at the right of each axiom.</p>
<p>Also note the panels on the right: Comments and Project Feed. These are
new capabilities in Web Protégé to facilitate collaborative design of
ontologies. We will demonstrate that shortly. First, you can navigate
the class hierarchy by clicking on the triangles at the left of each
class that has at least one subclass. This will expand the class and
show its subclasses. Click on Pizza to see its subclasses. For our
scenario imagine we are opening a new branch of our pizza store in
Chicago and we are dealing with a domain expert in Chicago pizza. As
they examine the hierarchy, they are appalled to see that there is no
class for ChicagoPizza, a type of deep dish Pizza that first became
popular in Chicago. Click on NamedPizza. Then click on the icon at the
left corner of the Comments view. If you hover the mouse over this icon
you should see the prompt Start new thread indicating the functionality of
this icon. Make sure NamedPizza is still selected and then click on the
icon to start a new thread. This will bring up a window titled Edit
where you can begin a new thread. Type something like: We need a
subclass of NamedPizza called ChicagoPizza. It should have an axiom that
requires it to have a DeepPanBase. Then hit the OK button. Your UI
should look similar to figure 12.4.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/image104.png"><img alt="_images/image104.png" src="_images/image104.png" style="width: 6.5in; height: 4.43889in;" /></a>
</figure>
<p>Figure 12.4 Creating a Discussion Thread</p>
<p>Note the new comment in the Comments view and the update in the Project
Feed view. The Comments view captures comments made on any entity in the
ontology. The Project Feed view captures each change made to the
ontology.</p>
<p>To see what threaded discussions look like click on the new comment and
select Reply. Add a comment like: I agree, ChicagoPizza is awesome and
deserves its own class.</p>
<p>Let’s address this comment by creating a new subclass of NamedPizza.
Select NamedPizza in the Class Hierarchy view. Note the icon in the
upper right corner of this view that looks similar to this: O+. When you
hover over this icon it should say Create. You can use this icon to
create new classes and subclasses. Make sure NamedPizza is still
selected and click on this icon to create a new subclass of NamedPizza.
This will bring up a dialog titled Create Classes. In the Class names
field enter the name ChicagoPizza.</p>
<p>You can leave the Language Tag field empty. Click on the Create button.
You should now see ChicagoPizza as a new subclass of NamedPizza. Note
that at the top of the Project Feed there should be a new entry for your
action of creating this new class.</p>
<p>You might be tempted to resolve this thread (note the Resolve link at
the top of the initial comment) however, we aren’t really done. Remember
that we need to not just create the class but also define the axiom that
a ChicagoPizza must have a DeepPanBase. Since we can’t add axioms in Web
Protégé we need to export our ontology back to Protégé. Typically, we
would collect many more comments and changes before exporting but we
want to demonstrate how round-trip editing works between Protégé and Web
Protégé. We could of course just export the ontology from Web Protégé to
Protégé and then create another new Project, but it would be cumbersome
to have to constantly create new projects every time you want to make a
change in Protégé and if we did this, we would lose our audit trail of
comments and changes. Luckily, there is a better way to do it.</p>
<p>To start we need to export the ontology to a file. Note that one of the
tabs at the top is History. Select that tab. This tab shows a list of
each version of the ontology. There should be 2 versions labelled R1 and
R2 (in the right corner of each version). The most recent version is
always at the top since that is typically what you want although it is
also possible to roll back changes to previous versions. We want to
export the latest version R2. Click on the R2 icon. This should give you
a drop-down menu with two options: Revert changes in revision 2 and
Download revision 2. Select Download revision 2. This will prompt you
with the standard file browser for your OS to save a zip file with the
new ontology. The ontology is saved with a zip file because ontologies
can be large and since Web Protégé is working over a network we may want
to limit the network traffic for large ontologies. Select the
appropriate place to save the Zip archive file on the machine where you
have Protégé. Do the standard things you would do to unzip the file and
load it into Protégé. Note that when you unzip the file it will create a
directory as well, so the file won’t be directly under whatever
directory you save it to. Instead, there will be a directory titled
something like pizza-with-data-ontologies-owl-REVISION-2 that the OWL
file will be in.</p>
<div class="line-block">
<div class="line">Load the downloaded file into Protégé. Go to the Class hierarchy tab
and navigate to the new</div>
<div class="line">ChicagoPizza class under NamedPizza. Add the axiom (refer back to
chapter 4 if you need to remember how to add axioms to classes)
hasBase some DeepPanBase. Save the file. Now go back to Web Protégé
and your version of the Pizza ontology there. Note that in the upper
right corner of the window there are links (drop down menus) such as
Display and Project. Select Project and from the drop down menu select
Apply External Edits. This will give you a small dialog titled Upload
ontologies with a little button to Choose File. Click on Choose File.
That will give you the standard OS dialog for selecting a file.
Navigate to the file you saved from Protégé and select that then
choose OK. That should result in a new pop-up window titled Merge
ontologies where you will see the changes (in this case only the
addition of the ChicagoPizza axiom) and a text box where you can
describe the changes. Add an appropriate Commit message or just take
the default and select OK. You should get a message that says the
changes were successfully applied.</div>
</div>
<p>If you navigate back to ChicagoPizza you should see that it now has that
axiom. You can also navigate back to NamedPizza. In the right most
column, you should see the comments about needing to add ChicagoPizza as
a subclass. Now that this has been done you can click on the Resolve
link in the upper right corner of the comment thread and the comments
will be removed from NamedPizza.</p>
<p>Chapter 13 Conclusion: Some Personal Thoughts and Opinions</p>
<div class="line-block">
<div class="line">This tutorial is just the entry point to a technology that is entering
the <em>Slope of Enlightenment</em> in the Gartner technology hype cycle
[Gartner Hype Cycle]. Tim Berners-Lee published his paper on the
Semantic Web [Berners-Lee 2001] way back in 2001. At least in my
experience for most large US corporations the excitement around
Machine Learning seemed for a while to eclipse serious interest in
OWL, SPARQL, and other Semantic Web technologies in the United States.
Then Google [Singhal 2012] coined the term “knowledge graph”. After
that, Facebook [Olanof 2013], Amazon [Neptune 2017], and many other
technology leaders started to embrace the technology [Noy 2019]. The
corporate world is finally realizing that machine learning and
knowledge graphs are complementary not competitive technologies. In an
article I recently wrote with Biswanath Dutta (publication pending) on
how</div>
<div class="line">knowledge graphs contributed to combatting the Covid-19 pandemic the
vast majority of the systems developed with knowledge graphs utilized
machine learning for tasks such as converting from “strings to
things”.</div>
</div>
<p>The term knowledge graph itself can be used in different ways. The best
definition I’ve heard is that an ontology provides the vocabulary (i.e.,
essentially the T-Box) and a knowledge graph is an ontology combined
with data (A-Box). Although in the corporate world I often hear people
simply talk about knowledge graphs without much interest in the
distinction between the vocabulary and the data.</p>
<p>There are a number of vendors emerging who are using the technology in
very productive ways and are providing the foundation for federated
knowledge graphs that can scale to hundreds of millions of triples or
more and provide a framework for all corporate data. I’ve listed several
in the bibliography but those are only the ones I’ve had some experience
with. I’m sure there are many others. One of the products I’ve had the
best experience with is the AllegroGraph triplestore and the Gruff
visualization tool from Franz Inc. Although Allegro is a commercial
tool, the free version supports most of the core capabilities of the
commercial version. I’ve found the Allegro triplestore easy to use on a
Windows PC with the Docker tool to emulate a Linux server.</p>
<p>I first started working with classification-based languages when I
worked at the Information Sciences Institute (ISI) and used the Loom
language [Macgregor 91] to develop B2B systems for the US Department of
Defense and their contractors. Since then, I’ve followed the progress of
the technology, especially the DARPA knowledge sharing initiative
[Neches 91] and always thought there was great promise in the
technology. When I first discovered Protégé it was a great experience.
It is one of the best supported and most usable free tools I’ve ever
seen, and it always surprised me that there weren’t more corporate users
leveraging it in major ways. I think we are finally starting to see this
happen and I hope this tutorial helps in a small way to accelerate the
adoption of this powerful and robust tool.</p>
<p>Chapter 14 Bibliography
Rather than a standard bibliography, this section is divided into various categories based on resources that will be valuable for future exploration of the technologies and methods described in this tutorial.
14.1 W3C Documents
OWL 2 Primer: <a class="reference external" href="https://www.w3.org/TR/owl2-primer/">https://www.w3.org/TR/owl2-primer/</a>
OWL 2 Specification: <a class="reference external" href="https://www.w3.org/TR/owl2-overview/">https://www.w3.org/TR/owl2-overview/</a>
Semantic Web Primer for Object-Oriented Software Developers: <a class="reference external" href="https://www.w3.org/TR/sw-oosd-primer/">https://www.w3.org/TR/sw-oosd-primer/</a>
SPARQL Specification: <a class="reference external" href="https://www.w3.org/TR/sparql11-query/">https://www.w3.org/TR/sparql11-query/</a>
SWRL Specification and Built-ins: <a class="reference external" href="https://www.w3.org/Submission/SWRL/">https://www.w3.org/Submission/SWRL/</a>
14.2 Web Sites, Tools, And Presentations.
Agile Alliance: <a class="reference external" href="https://www.agilealliance.org/agile101/">https://www.agilealliance.org/agile101/</a>
Cellfie: <a class="reference external" href="https://github.com/protegeproject/cellfie-plugin/wiki/Grocery-Tutorial">https://github.com/protegeproject/cellfie-plugin/wiki/Grocery-Tutorial</a>
Gartner Hype Cycle: <a class="reference external" href="https://www.gartner.com/en/research/methodologies/gartner-hype-cycle">https://www.gartner.com/en/research/methodologies/gartner-hype-cycle</a>
Jena: Open Source Java Framework for Semantic Web and Linked Data Applications: <a class="reference external" href="https://jena.apache.org/">https://jena.apache.org/</a>
Open World Assumption (OWA) presentation by Nick Drummond and Rob Shearer: <a class="reference external" href="http://www.cs.man.ac.uk/~drummond/presentations/OWA.pdf">http://www.cs.man.ac.uk/~drummond/presentations/OWA.pdf</a>
Protégé: <a class="reference external" href="https://protege.stanford.edu/">https://protege.stanford.edu/</a>
Protégé Best Practices. Summary page on my blog for all my articles on Protégé, OWL, SWRL, etc.: <a class="reference external" href="https://www.michaeldebellis.com/post/best-practices-for-new-protege-users">https://www.michaeldebellis.com/post/best-practices-for-new-protege-users</a>
SHACL Playground: <a class="reference external" href="https://shacl.org/playground/">https://shacl.org/playground/</a>
SWRL Presentation by Martin O’Connor: <a class="reference external" href="https://protege.stanford.edu/conference/2009/slides/SWRL2009ProtegeConference.pdf">https://protege.stanford.edu/conference/2009/slides/SWRL2009ProtegeConference.pdf</a>
WebProtégé: <a class="reference external" href="https://webprotege.stanford.edu/">https://webprotege.stanford.edu/</a>
WebVOWL: Web-based Visualization of Ontologies: <a class="reference external" href="http://vowl.visualdataweb.org/webvowl.html">http://vowl.visualdataweb.org/webvowl.html</a>
14.3 Papers
Berners-Lee (2001). The Semantic Web: A new form of Web content that is meaningful to computers will unleash a revolution of new possibilities. With James Hendler and Ora Lassila. Scientific American, May 17, 2001. <a class="reference external" href="https://tinyurl.com/BernersLeeSemanticWeb">https://tinyurl.com/BernersLeeSemanticWeb</a>
MacGregor, Robert (1991). “Using a description classifier to enhance knowledge representation”. IEEE Expert. 6 (3): 41–46. doi:10.1109/64.87683 https://tinyurl.com/MacGregorLoom
Neches, Robert (1991). Enabling Technology for Knowledge Sharing. With Richard Fikes, Tim Finin, Thomas Gruber, Ramesh Patil, Ted Senator, and William T. Swartout. AI Magazine. Volume 12 Number 3 (1991). https://tinyurl.com/DARPAKnowledgeSharing
Noy, Natasha (2019). Industry-Scale Knowledge Graphs: Lessons and Challenges. With Yuqing Gao, Anshu Jain, Anant Narayanan, Alan Patterson, Jamie Taylor. Communications of the ACM. Vol. 62. No. 8. August 2019. https://tinyurl.com/ACMKnowledgeGraphs
M. J. O’Connor (2012). A Pair of OWL 2 RL Reasoners. With A.K. Das. OWL: Experiences and Directions (OWLED), 9th International Workshop, Heraklion, Greece, 2012. http://ceur-ws.org/Vol-849/paper_31.pdf
Singhal, Amit. (2012). Introducing the Knowledge Graph: things, not strings. Google SVP, Engineering. May 16, 2012. https://www.blog.google/products/search/introducing-knowledge-graph-things-not/
14.4 Books
DuCharme, Bob (2011). Learning SPARQL. O’Reilly Media
Lewis, Harry. (1997). Elements of the Theory of Computation. With Christos Papadimitriou. Prentice-Hall; 2nd edition (August 7, 1997). ISBN-13: 978-0132624787
Segaran, Toby (2009). Programming the Semantic Web: Build Flexible Applications with Graph Data. With Colin Evans and Jamie Taylor. O’Reilly Media; 1st edition (July 28, 2009).
14.5 Vendors
AllegroGraph Triplestore (Franz Inc.): https://franz.com/
Amazon Neptune: https://aws.amazon.com/neptune/
Docker: https://www.docker.com/
Dynaccurate: https://www.dynaccurate.com/
Ontotext: https://www.ontotext.com/
Pool Party: https://www.poolparty.biz/
Stardog: https://www.stardog.com/
Top Quadrant: https://www.topquadrant.com/</p>
<h1 id="chapter-11"><span id="chap11"></span><span class="sectnum">11. </span>Chapter 11<a class="headerlink" href="#chapter-11" title="Permalink to this heading">¶</a></h1>
<h1 id="chapter-12"><span id="chap12"></span><span class="sectnum">12. </span>Chapter 12<a class="headerlink" href="#chapter-12" title="Permalink to this heading">¶</a></h1>
<h1 id="chapter-13"><span id="chap13"></span><span class="sectnum">13. </span>Chapter 13<a class="headerlink" href="#chapter-13" title="Permalink to this heading">¶</a></h1>
<div class="toctree-wrapper compound">
</div>



              
            </article>
          </div>
        </div>
        
          <a href="#" class="md-top md-icon" data-md-component="top" data-md-state="hidden">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
            Back to top
          </a>
        
      </main>
      
        <footer class="md-footer">
  
  
  
  <div class="md-footer-meta md-typeset">
    
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-footer-copyright__highlight">
        &#169; Copyright 2022, Michael DeBellis.
        
    </div>
  
    Created using
    <a href="https://www.sphinx-doc.org/" target="_blank" rel="noopener">Sphinx</a>
    5.0.1.
     and
    <a href="https://github.com/jbms/sphinx-immaterial/" target="_blank" rel="noopener">Sphinx-Immaterial</a>
  
</div>
      
    </div>
    
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": ".", "features": ["navigation.top", "search.share"], "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="_static/javascripts/bundle.37d1338f.min.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/clipboard.min.js"></script>
        <script src="_static/copybutton.js"></script>
        <script src="_static/design-tabs.js"></script>
    
  </body>
</html>